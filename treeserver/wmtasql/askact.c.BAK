/*********
 * askact.c
 * copyright (c) EastUnion Computer Service Ltd., Co. 1995
 *               Shanghai Zhongtie Software Company. 1997
 *		 Shanghai Withub Vision Software Co., Ltd. 1998-2000
 *
 * author:  Xilong Pei
 *
 * version:
 *    2.0
 * Rem:
 *    1995.10.31 make it Watcom C compilable
 *    1997.1	add sigmaX(), sigmay()
 *    1997.3.18 the field's name generated by warray() begin from 1, not 0
 *    1997.10.1 add _ASK_Goto()
 *
 *    1999.11.5 CONDITION
 *		BEGIN
 *                  AVERAGE xStat, ySum,ySumExpr,xStatExpr
 *		END                                 ^
 *                                                  |
 *                                                  +-- new added
 *
 *
 * Notice:
 *    every action must set its return type after it worked even it need
 * not execute this time
 ****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <io.h>
#include <dos.h>


#include "dir.h"
#include "mistring.h"
#include "mistools.h"
#include "dio.h"
#include "dioext.h"
#include "xexp.h"
#include "btree.h"
#include "asqlana.h"
#include "tabtools.h"
#include "strutl.h"
#include "diodbt.h"
#include "wst2mt.h"
#include "tsdbfutl.h"
#include "ts_const.h"
#include "exchbuff.h"
#include "asqlutl.h"


#define cONCEMALLOCSYMBOLNUM   (char)4
WSToMT short    in4096Buf;
WSToMT char     s4096Buf[4096];


////////////////// inside function ///////////////////////////////////////
short PD_style num_Ask_AsqlStat_X( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState, OpndType *numlpOpnd );
/////////////////


/*
----------------------------------------------------------------------------
!!                      ActionSymbolRegister()
----------------------------------------------------------------------------*/
//#pragma argsused
MidCodeType * PD_style ActionSymbolRegister( MidCodeType *m_c_head, \
			     dFILE *stb, dFILE *ttb, \
			     SysVarOFunType *UserSymbol, short SymbolNum, \
			     SYSDEFINETYPE *DefineTable, short DefineNum )
{
extern WSToMT FromToStru fFrTo;

    if( ttb == NULL ) {
        if( fFrTo.phuf != NULL )
        { //update statement appeared
            askTdf = stb;
        } else {
	    askTdf = (dFILE *)1;
        }
    } else {
#ifdef WSToMT
        if( stb != NULL && ttb->pdf == stb->pdf && ttb->pdf != NULL )
        {                      //target is dcreate() source is dcreate()
	    askTdf = stb;
        } else
#endif
	    askTdf = ttb;

    }

    m_c_head = SymbolRegister(m_c_head, stb, UserSymbol, SymbolNum, \
						    DefineTable, DefineNum );

    //set to normal expression
    askTdf = NULL;

    return  m_c_head;

} /* end of function ActionSymbolRegister() */



/*
----------------------------------------------------------------------------
!!                      ActionCalExpr()
----------------------------------------------------------------------------*/
//#pragma argsused	   /* Remed by NiuJingyu */
long PD_style ActionCalExpr(MidCodeType *m_c_head, short *CurState, dFILE *tdf)
{
    long  l;

    ASKACTIONCURRENTSTATEshort = CurState;

    if( (askTdf = tdf) == NULL ) {
	askTdf = (dFILE *)1;
    }

    l = CalExpr( m_c_head );

    //set to normal expression
    askTdf = NULL;

    return  l;

} /* end of function ActionCalExpr() */



/*
----------------------------------------------------------------------------
!!                      ActionAnalyse()
----------------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
MidCodeType * PD_style ActionAnalyse( unsigned char *buffer, short ActionNo, \
			    SysVarOFunType **SymbolTable, \
			    short *SymbolNum, FIELDNAMETYPE **FieldTable, \
			    short *FieldNum, SYSDEFINETYPE *DefineTable, \
			    short *DefineNum )
{
     MidCodeType  *m_c_head, *m_c_pointer, *mpp, *mpRem;
     void   *p;
     char   *TempStr, szBuf[256];
     char NewSymbolNum = cONCEMALLOCSYMBOLNUM;
     char NewFieldNum = cONCEMALLOCSYMBOLNUM;
     unsigned short i;
     //short Functions, SquareBrackets;

     if( buffer == NULL )       return( NULL );

     /*if( *FieldTable == NULL ) {
	 *FieldNum = 0;
	 *FieldTable = (FIELDNAMETYPE *)malloc( cONCEMALLOCSYMBOLNUM * sizeof(FIELDNAMETYPE));
	 NewFieldNum = 0;
     }
     */
     if( *SymbolTable == NULL ) {
	 *SymbolNum = 0;
	 *SymbolTable = (SysVarOFunType *)malloc( cONCEMALLOCSYMBOLNUM*sizeof(SysVarOFunType) );
	 NewSymbolNum = 0;
     }

     /* analyse as normal expression */
     m_c_pointer = m_c_head = WordAnalyse( buffer );

     /* rescan it for symbols register */
     while( m_c_pointer != NULL ) {
	/* SymbolRegister() will deal the DefineTable, but now we have
	   to deal them for variable register */
	switch( m_c_pointer->type ) {
	    case FUNB_TYPE:
		/* look for action table for select */
		if( ( p = AskActionSearch(m_c_pointer->values, \
			    AskActionTable, AskActionFunNum ) ) == NULL ) {
			if( ( p = AskActionSearch(m_c_pointer->values, \
					(AskActionType *)SysFun, SysFunNum) ) == NULL ) {
				FreeCode(m_c_head);
				ErrorSet.xERROR = iNoAction;      /* no this action */
				strcpy(ErrorSet.string, m_c_pointer->values);
				return  NULL;
			}
		}

		switch( ((AskActionType *)p)->type ) {  /* store as Action no */
		    case _Ask_askcnt:
			m_c_pointer->length = 1;
			m_c_pointer = m_c_pointer->next;
                        if( m_c_pointer->type != STRING_TYPE && \
                            m_c_pointer->type != IDEN_TYPE)
                        { //para is too less
                                FreeCode(m_c_head);
				ErrorSet.xERROR = iFailFunCall;
				strcpy(ErrorSet.string, "askcnt()");
				return  NULL;
                        } else {
                               strZcpy(szBuf, m_c_pointer->values, MAX_OPND_LENGTH);
                               m_c_pointer->type = VIDEN_TYPE;

			       //add self(import) variable support, 2000.4.20
			       for(i = 0;  i < nSelfBaseVar && \
				     stricmp(szBuf, \
				     xSelfBaseVar[i].VarOFunName) != 0; i++ );
			       if( i < nSelfBaseVar ) {
				   strcpy(m_c_pointer->values, szBuf);
				   m_c_pointer->length = \
					*(short *)(*SymbolTable)[i].values = i;
				   goto  ActionAnalyse_Found1;
			       }
			       
		               for(i = 0;  i < *SymbolNum && \
				     stricmp(szBuf, \
				     (*SymbolTable)[i].VarOFunName) != 0; i++ );
		               if( i >= *SymbolNum ) {
			           if( NewSymbolNum >= cONCEMALLOCSYMBOLNUM ) {
				     if( (*SymbolTable = (SysVarOFunType *)realloc(*SymbolTable, \
					  (*SymbolNum+cONCEMALLOCSYMBOLNUM)*sizeof(SysVarOFunType) )) == NULL )
                                     {
                                        FreeCode(m_c_head);
					ErrorSet.xERROR = iNoMem;
				        return  NULL;
			             }
				     NewSymbolNum = 0;
                                   }
			           (*SymbolTable)[i].type = LONG_IDEN;
				   (*SymbolTable)[i].length = sizeof(long);
				   strZcpy((*SymbolTable)[i].VarOFunName, szBuf, MAX_OPND_LENGTH);
				   NewSymbolNum++;
			           (*SymbolNum)++;
                               }

			       strcpy(m_c_pointer->values, szBuf);
			       m_c_pointer->length = \
					*(short *)(*SymbolTable)[i].values = i;
                        }

ActionAnalyse_Found1:
			while( m_c_pointer->next->type != FUNE_TYPE ) {
                               mpp = m_c_pointer->next;
                               m_c_pointer->next = mpp->next;
                               free(mpp);
			       m_c_pointer = m_c_pointer->next;
			} /* end of while */
			break;

		    case _Ask_askavg:
		    case _Ask_askmax:
		    case _Ask_askmin:
		    case _Ask_asksum:
			/* one item one symbol */
			/* register the symbol, the symbol is writen as:
			 * Field.Max */
			mpRem = m_c_pointer;
			m_c_pointer = m_c_pointer->next;
			while( m_c_pointer->type != FUNE_TYPE ) {
			       if( m_c_pointer->type != IDEN_TYPE ) {
				   if( m_c_pointer->type != PARAL_TYPE ) {
					FreeCode(m_c_head);
					ErrorSet.xERROR = iFailFunCall;
					strcpy(ErrorSet.string, "ask...");
					return  NULL;
				   }

				   m_c_pointer = m_c_pointer->next;
				   continue;
			       }

			       TempStr = NULL;
			       strcpy(szBuf, m_c_pointer->values);

			       //f(para1)   f(para1,para2)
			       if( m_c_pointer->next->type != FUNE_TYPE )
			       {
				   //f(para1, para2)
				   //  |    |   |  |
				   //  +----+---+--+
				   mpp = m_c_pointer->next;
				   if( mpp->next->type == STRING_TYPE )
				   {
					    //free ','
					    m_c_pointer->next = mpp->next;
					    free(mpp);
					    mpp = m_c_pointer->next;

					    // '0' is less the smallest action no
					    strcat(szBuf, ".0");
					    strcat(szBuf, subcopy(mpp->values,0,16));
					    TempStr = strchr(szBuf, '.') + 2;

					    //free para2
					    m_c_pointer->next = mpp->next;
					    free(mpp);

					    mpRem->length--;
				    }
			       }
			       if( TempStr == NULL ) {

				   char buf[16];

				   TempStr = szBuf;
				   itoa(((AskActionType *)p)->type, buf, 10);
				   strcat(szBuf, ".");
				   strcat(szBuf, buf);
			       }
			       m_c_pointer->type = FIELD_IDEN;

			       //add self(import) variable support, 2000.4.20
			       for(i = 0;  i < nSelfBaseVar && \
				     stricmp(TempStr, \
				     xSelfBaseVar[i].VarOFunName) != 0; i++ );
			       if( i < nSelfBaseVar ) {
				    if( xSelfBaseVar[i].type == STRING_IDEN ) {
					   FreeCode(m_c_head);
					   ErrorSet.xERROR = iSymbolUsedError;
					   strcpy(ErrorSet.string, TempStr);
					   return  NULL;
				   }				   
				   strcpy(m_c_pointer->values, szBuf);
				   m_c_pointer = m_c_pointer->next;

				   goto  ActionAnalyse_Found2;
			       }

			       for(i = 0;  i < *SymbolNum && \
				     stricmp(TempStr, \
				     (*SymbolTable)[i].VarOFunName) != 0; i++ );
			       if( i >= *SymbolNum ) {
				   if( NewSymbolNum >= cONCEMALLOCSYMBOLNUM ) {
				       if( (*SymbolTable = (SysVarOFunType *)realloc(*SymbolTable, \
					  (*SymbolNum+cONCEMALLOCSYMBOLNUM)*sizeof(SysVarOFunType) )) == NULL )
				       {
					   FreeCode(m_c_head);
					   ErrorSet.xERROR = iNoMem;
					   return  NULL;
				       }
				       NewSymbolNum = 0;
				   }
				   (*SymbolTable)[i].type = LONG_IDEN;
				   (*SymbolTable)[i].length = sizeof(long);
				   strZcpy((*SymbolTable)[i].VarOFunName, TempStr, MAX_OPND_LENGTH);
				   NewSymbolNum++;
				   (*SymbolNum)++;
			       } else {
				   if( (*SymbolTable)[i].type == STRING_IDEN ) {
					   FreeCode(m_c_head);
					   ErrorSet.xERROR = iSymbolUsedError;
					   strcpy(ErrorSet.string, TempStr);
					   return  NULL;
				   }
			       }

			       /*???, no use
				m_c_pointer->length = \
					*(short *)(*SymbolTable)[i].values = i;
				*/

			       /* use for m_c_pointer and the symbol corresponding */
			       strcpy(m_c_pointer->values, szBuf);
			       m_c_pointer = m_c_pointer->next;
ActionAnalyse_Found2:
			       ;
			} /* end of while */
			break;
		    /*case _Ask_askrec:
			// register the field, fields shouldn't be sorted!
			// and empty the parameter *
			m_c_pointer = m_c_pointer->next;
			while( m_c_pointer->type != FUNE_TYPE ) {
				TempStr = (char *)m_c_pointer->values;
				for(i = 0;  i < *FieldNum;  i++ ) {
				       if( *TempStr == '@' )
					   if( memicmp(TempStr, (*FieldTable)[i].FieldName, sizeof(SPECIALFIELDSTRUCT) ) != 0 ) break;
				       else
					   if( stricmp(TempStr, (*FieldTable)[i].FieldName) != 0 )      break;
				}
				if( i >= *FieldNum ) {
				   if( NewFieldNum >= cONCEMALLOCSYMBOLNUM ) {
				       *FieldTable = (FIELDNAMETYPE *)realloc(*FieldTable, \
					  (*FieldNum+cONCEMALLOCSYMBOLNUM)*FIELDNAMELEN );
				       NewFieldNum = 0;
				   }
				   memcpy((*FieldTable)[*FieldNum].FieldName, TempStr, sizeof(FIELDNAMETYPE));
				   (*FieldNum)++;
				   NewFieldNum++;
				} // end of if i>= *FieldNum

				// skip to the next parameter
				Functions = SquareBrackets = 0;
				do {
				    m_c_pointer = m_c_pointer->next;
				    switch( m_c_pointer->type ) {
					case FUNB_TYPE:   Functions++;            break;
					case FUNE_TYPE:   Functions--;            break;
					case ARRAYB_TYPE: SquareBrackets++;       break;
					case ARRAYE_TYPE: SquareBrackets--;       break;
					case PARAL_TYPE:
						if( Functions == 0 && SquareBrackets == 0 ) {
							m_c_pointer = m_c_pointer->next;
							Functions = -1;
						}
				    }
				} while( m_c_pointer != NULL && Functions >= 0 );

			} // end of while
			//!!97.3.24 m_c_pointer = m_c_pointer->next;
			break;
			*/
		} /* end of switch p->type */
	} /* end of switch */

	m_c_pointer = m_c_pointer->next;

     } /* end of while */

     /* shrink the memory */
     *SymbolTable = (SysVarOFunType *)realloc(*SymbolTable, (*SymbolNum) * sizeof(SysVarOFunType) );

     *FieldTable = NULL;
     *FieldNum = 0;
     /*if( *FieldNum < 2 ) {
	free(*FieldTable);
	*FieldTable = NULL;
	*FieldNum = 0;
     } else
	*FieldTable =  (FIELDNAMETYPE *)realloc(*FieldTable, (*FieldNum) * sizeof(FIELDNAMETYPE));
     */

     return( m_c_head );

} /*  end of ActionAnalyse()  */


/*
----------------------------------------------------------------------------
!!                      AskActionSearch()
----------------------------------------------------------------------------*/
AskActionType * PD_style AskActionSearch( const unsigned char *Key, \
				AskActionType *Base, short BaseKeyNum )
{

    short Low, Mid, CompValue;

    Low = 0;

    while( Low <= BaseKeyNum ) {
	Mid = ( Low + BaseKeyNum ) / 2;
#ifdef XexpCaseSensitive
	if( ( CompValue = strcmp(Key, Base[Mid].VarOFunName) ) == 0 )
		return  &Base[Mid];
#else
	if( ( CompValue = stricmp(Key, Base[Mid].VarOFunName) ) == 0 )
		return  &Base[Mid];
#endif
	if( CompValue > 0 )     Low = Mid + 1;
	else                    BaseKeyNum = Mid - 1;
    }

    return  NULL;

} /* end of AskActionSearch() */




/*<<<<<<<<<<<<<<<<<<<<<< ASK Action Function body >>>>>>>>>>>>>>>>>>>>>>>>>*/

/*------------
 !                      _ASK_MAX()
 ! protocol: askmax
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_MAX( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
/* OpndType *lpOpnd;               pointer of opnd stack */
/* short ParaNum;                  parameter number for this action */
/* short *OpndTop;                 system opnd top */
/* short *CurState;                the action sequence working state */
{
    short i;

    dFIELDWHENACTION *p;

    if( *CurState == 0 ) {  /* first work of this action */
	for( i = 0;  i < ParaNum;  i++ ) {
	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	/* now the values field of opnd struct is the pointer of symbol
	 * values storage */
	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     *((long *)p->ResultMem) = LONG_MIN;
		     break;
		case FFIELD_IDEN:
		     *(double *)p->ResultMem = FLOAT_MIN;
	     }
	}
    } else if( *CurState > 0 ) {
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     *(long *)p->ResultMem = max( *(long *)p->ResultMem, \
					    atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) ) );
		     break;
		case FFIELD_IDEN:
		     *((double *)p->ResultMem) = max(*(double *)p->ResultMem, \
				       atof( SubstrOutBlank(p->pSourceStart, 0, \
				       lpOpnd[i].length) ) );
	     }
	}
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_MAX() */

/*------------
 !                      _ASK_MIN()
 ! protocol: askmin
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_MIN( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
/* OpndType *lpOpnd;               pointer of opnd stack */
/* short ParaNum;                  parameter number for this action */
/* short *OpndTop;                 system opnd top */
/* short *CurState;                the action sequence working state */
{
    short i;
    dFIELDWHENACTION *p;

    if( *CurState == 0 ) {  /* first work of this action */
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	/* now the values field of opnd struct is the pointer of symbol
	 * values storage */
	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     *((long *)p->ResultMem) = LONG_MAX;
		     break;
		case FFIELD_IDEN:
		     *(double *)p->ResultMem = FLOAT_MAX;
	     }
	}
    } else if( *CurState > 0 ) {
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     *(long *)p->ResultMem = min( *(long *)p->ResultMem, \
					    atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) ) );
		     break;
		case FFIELD_IDEN:
		     *((double *)p->ResultMem) = min(*(double *)p->ResultMem, \
				       atof( SubstrOutBlank(p->pSourceStart, 0, \
				       lpOpnd[i].length) ) );
	     }
	}
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_MIN() */



/*------------
 !                      _ASK_SUM()
 ! protocol: asksum
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_SUM( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
/* OpndType *lpOpnd;               pointer of opnd stack */
/* short ParaNum;                  parameter number for this action */
/* short *OpndTop;                 system opnd top */
/* short *CurState;                the action sequence working state */
{
    short i;
    dFIELDWHENACTION *p;

    if( *CurState == 0 ) {  /* first work of this action */
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	/* now the values field of opnd struct is the pointer of symbol
	 * values storage */
	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     *((long *)p->ResultMem) = 0L;
		     break;
		case FFIELD_IDEN:
		     *(double *)p->ResultMem = 0.0;
		break;
	     }
	}
    } else if( *CurState > 0 ) {
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
		     //if( p == NULL )    p = (dFIELDWHENACTION *)lpOpnd[i].values;
		     *(long *)p->ResultMem += atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
		     break;
		case FFIELD_IDEN:
		     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
		     *(double *)p->ResultMem += atof( SubstrOutBlank(p->pSourceStart, 0, \
				       lpOpnd[i].length) );
		     break;
	     }
	}
    } // end of if

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_SUM() */


/*------------
 !                      _ASK_CNT()
 ! protocol: askcnt
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_CNT( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
/* OpndType *lpOpnd;               pointer of opnd stack */
/* short ParaNum;                  parameter number for this action */
/* short *OpndTop;                 system opnd top */
/* short *CurState;                the action sequence working state */
{
    if( *CurState == 0 ) {  /* first work of this action */
	/* now the values field of opnd struct is the pointer of symbol
	 * values storage */
	 *(long *)*(long *)lpOpnd[0].values = 0L;
    } else if( *CurState > 0 ) {
	(*(long *)*(long *)lpOpnd[0].values)++;
    } // end of if

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_CNT() */


/*------------
 !                      _ASK_AVG()
 ! protocol: askavg
 ! modify this function 2000/2/28
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_AVG( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
{
    short i;
    dFIELDWHENACTION *p;

    //now the buffer is stored as: count(long), sumvalues
    if( *CurState == 0 )
    { //first work of this action
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	/* now the values field of opnd struct is the pointer of symbol
	 * values storage
	 */
	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     *((long *)((char *)p->ResultMem+sizeof(long))) = 0L;
		     *((long *)p->ResultMem) = 0L;
		     break;
		case FFIELD_IDEN:
		     *((long *)((char *)p->ResultMem+sizeof(double))) = 0L;
		     *((double *)p->ResultMem) = 0.0;
		     break;
	     }
	}
//    } else if( *CurState > 0 ) {
    } else if( *CurState == NORMAL_ACTION ) {
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		     (*(long *)( (char *)p->ResultMem+sizeof(long)) )++;
		     *((long *)p->ResultMem) += \
					    atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
		     break;
		case FFIELD_IDEN:
		     (*(long *)( (char *)p->ResultMem+sizeof(double)) )++;
		     *((double *)p->ResultMem) += \
				       atof( SubstrOutBlank(p->pSourceStart, 0, \
				       lpOpnd[i].length) );
	     }
	}
    } /* end of if */ else {    // *CurState == LASTWORKTIMEOFACTION
				// || *CurState == GROUPBY_ACTION
	for( i = 0;  i < ParaNum;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     switch( lpOpnd[i].type ) {

		long    l;

		case NFIELD_IDEN:
		     l = *((long *)((char *)p->ResultMem+sizeof(long)));
		     if( l == 0 )       l = 1;
		     *((long *)p->ResultMem) /= l;
		     break;
		case FFIELD_IDEN:
		     l = *((long *)((char *)p->ResultMem+sizeof(double)));
		     if( l == 0 )       l = 1;
		     *((double *)p->ResultMem) /= l;

	     }
	}
    }
    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_AVG() */


/*------------
 !                      _ASK_WSYMBOL()
 ! protocol: wsymbol()
 !-----------------------------------------------------------------------*/
//#pragma argsused /* Remed by NiuJingyu */
short PD_style _ASK_WSYMBOL( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
/* OpndType *lpOpnd;               pointer of opnd stack */
/* short ParaNum;                  parameter number for this action */
/* short *OpndTop;                 system opnd top */
/* short *CurState;                the action sequence working state */
{
#ifdef WSToMT
    int      i, j;
    dFILE   *gsDbf;
    char    *s;
    SysVarOFunType *UsrVar = *XexpUserDefinedVar;
    dFIELD  *field;
    char    nameBuf[MAXPATH];
    int     decs = 4;

    if( *CurState == ONE_MODALITY_ACTION ) {

	/*if( lpOpnd[0].oval == NULL ) {
		if( lpOpnd[0].length < MAX_OPND_LENGTH ) {
			strZcpy(nameBuf, lpOpnd[0].values, MAXPATH);
		} else {
			s = (char *)*(long *)lpOpnd[0].values;
			free(s);
			strZcpy(nameBuf, s, MAXPATH);
		}
	} else {
		strZcpy(nameBuf, lpOpnd[0].oval, MAXPATH);
	}*/
	s = xGetOpndString(&lpOpnd[0]);
	strZcpy(nameBuf, s, MAXPATH);

	if( ParaNum > 1 ) {
	    decs = xGetOpndLong(&lpOpnd[1]);
	    if( decs == LONG_MIN || decs > 10 )
		decs = 4;

	    for(i = 1;  i < ParaNum;  i++ ) {
		if( lpOpnd[i].type == STRING_TYPE && \
					lpOpnd[i].length >= MAX_OPND_LENGTH ) {
			free((char *)*(long *)lpOpnd[i].values);
		}
	    }
	}


	if( (field = calloc(*XexpUserDefinedVarNum+2, sizeof(dFIELD))) == NULL ) {
	    ErrorSet.xERROR = iNoMem;
	    return  1;
	}

	for(i = 0, j = 0;  i < *XexpUserDefinedVarNum;  i++) {
		switch( UsrVar[i].type ) {
		    case LONG_IDEN:
			field[j].fieldtype = 'N';
			field[j].fieldlen = 10;
			field[j].fielddec = 0;
			break;
		    case FLOAT_IDEN:
			field[j].fieldtype = 'N';
			field[j].fieldlen = 19;
			field[j].fielddec = decs;
			break;
		    case STRING_IDEN:
			field[j].fieldtype = 'C';
			field[j].fieldlen = min(UsrVar[i].length, 254);
			field[j].fielddec = 0;
			break;
		    case DATE_IDEN:
			field[j].fieldtype = 'D';
			field[j].fieldlen = 8;
			field[j].fielddec = 0;
			break;
		    case CHR_IDEN:
			field[j].fieldtype = 'C';
			field[j].fieldlen = 1;
			field[j].fielddec = 0;
			break;
		    case INT_IDEN:
			field[j].fieldtype = 'N';
			//clear the high WORD of *(long *)UsrVar[i].values
			//for ASQL treat it as long always
			*(long *)(UsrVar[i].values) = *(short *)(UsrVar[i].values);
			field[j].fieldlen = 5;
			field[j].fielddec = 0;
			break;
		    default:
			continue;
		} // end os switch
		strncpy(field[j].field, UsrVar[i].VarOFunName, FIELDNAMELEN-1);
		field[j].field[FIELDNAMELEN-1] = '\0';
		j++;
	} // end of for
	field[j].field[0] = '\0';

	makefilename(nameBuf, asqlEnv.szAsqlResultPath, nameBuf);
	gsDbf = dcreate(nameBuf, field);
	free(field);

	if( gsDbf == NULL ) {
	    ErrorSet.xERROR = iFailCreateFile;
	    return 1;
	}

	//dSetAwake(gsDbf, &gsDbf);
	//wmtDbfLock( gsDbf );

	for(i = 0, j = 0;  i < *XexpUserDefinedVarNum;  i++) {
		switch( UsrVar[i].type ) {
		    case LONG_IDEN:
		    case FLOAT_IDEN:
		    case STRING_IDEN:
		    case DATE_IDEN:
		    case CHR_IDEN:
		    case INT_IDEN:
			break;
		    default:
			continue;
		}
		if( UsrVar[i].type == STRING_IDEN && \
				       UsrVar[i].length >= MAX_OPND_LENGTH ) {
		    PutField(gsDbf, (short)j, (char *)*(long *)UsrVar[i].values);
		} else {
		    PutField(gsDbf, (short)j, UsrVar[i].values);
		}
		j++;
	} // end of for
	putrec(gsDbf);

	//wmtDbfUnLock( gsDbf );
	//dSleep( gsDbf );
	dclose( gsDbf );
    }
#else
    char *s;
    FILE *os;
    short i;
    SysVarOFunType *UsrVar = *XexpUserDefinedVar;

    if( *CurState == ONE_MODALITY_ACTION ) {
	if( lpOpnd[0].oval == NULL ) {
		if( lpOpnd[0].length < MAX_OPND_LENGTH ) {
			s = lpOpnd[0].values;
		} else {
			s = (char *)*(long *)lpOpnd[0].values;
		}
		os = fopen(s, "wt");
	} else {
		os = fopen(lpOpnd[0].oval, "wt");
	}
/*
	for(i = 0;  i < SysVarNum;  i++) {
		switch( SysVar[i].type ) {
		    case LONG_IDEN:
			fprintf(os, "%s=%ld\n", SysVar[i].VarOFunName, *(long *)SysVar[i].values);
			break;
		    case FLOAT_IDEN:
			fprintf(os, "%s=%f\n", SysVar[i].VarOFunName, \
					    *(double *)SysVar[i].values);
			break;
		    case STRING_IDEN:
			if( SysVar[i].length < MAX_OPND_LENGTH ) {
				fprintf(os, "%s=\"%s\"\n", SysVar[i].VarOFunName, \
							SysVar[i].values);
			} else {
				fprintf(os, "%s=\"%s\"\n", SysVar[i].VarOFunName, \
					    (char *)*(long *)SysVar[i].values);
			}
			break;
		} // end os switch
	} // end of for
*/
	for(i = 0;  i < *XexpUserDefinedVarNum;  i++) {
		switch( UsrVar[i].type ) {
		    case INT_IDEN:
			fprintf(os, "%s=%ld\n", UsrVar[i].VarOFunName, \
					    *(short *)UsrVar[i].values);
			break;
		    case LONG_IDEN:
			fprintf(os, "%s=%ld\n", UsrVar[i].VarOFunName, \
					    *(long *)UsrVar[i].values);
			break;
		    case FLOAT_IDEN:
			fprintf(os, "%s=%lf\n", UsrVar[i].VarOFunName, \
					    *(double *)UsrVar[i].values);
			break;
		    case STRING_IDEN:
			/*STRING_IDEN is stored indirectly. 1997.6.10
			if( SysVar[i].length < MAX_OPND_LENGTH ) {
				fprintf(os, "%s=\"%s\"\n", UsrVar[i].VarOFunName, \
							UsrVar[i].values);
			} else*/
			{
				fprintf(os, "%s=\"%s\"\n", UsrVar[i].VarOFunName, \
					    (char *)*(long *)UsrVar[i].values);
			}
		} // end os switch
	} // end of for

	fputs("\x1A", os);
	fclose(os);

    } // end of if
#endif
    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_WSYMBOL() */

/*------------
 !                      _ASK_x_SUM()
 !-----------------------------------------------------------------------*/
// #pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_x_SUM( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
/* OpndType *lpOpnd;               pointer of opnd stack */
/* short ParaNum;                  parameter number for this action */
/* short *OpndTop;                 system opnd top */
/* short *CurState;                the action sequence working state */
{
    short i, j;
    dFIELDWHENACTION *p;

    j = ParaNum-1;
    if( *CurState == 0 ) {  /* first work of this action */
	switch( lpOpnd[ j ].type ) {
	   case VCHR_IDEN:
		    *(char *)*(long *)lpOpnd[j].values = '\0';        break;
	   case VINT_IDEN:
		    *(short *)*(long *)lpOpnd[j].values = 0;          break;
	   case VLONG_IDEN:
		    *(long *)*(long *)lpOpnd[j].values = 0L;          break;
	   case VFLOAT_IDEN:
		    *(double *)*(long *)lpOpnd[j].values = 0.0;  break;
	} /* end of switch */
    } else if( *CurState > 0 ) {
	for( i = 0;  i < j;  i++ ) {

	     if( lpOpnd[i].type<FIELD_IDEN || lpOpnd[i].type>SFIELD_IDEN ) continue;

	     p = (dFIELDWHENACTION *)lpOpnd[i].oval;
	     //if( p == NULL )    p = (dFIELDWHENACTION *)lpOpnd[i].values;
	     switch( lpOpnd[i].type ) {
		case NFIELD_IDEN:
		switch( lpOpnd[ j ].type ) {
		    case VCHR_IDEN:
			*(char *)*(long *)lpOpnd[j].values += \
					    (char)atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
			break;
		    case VINT_IDEN:
			*(short *)*(long *)lpOpnd[j].values += \
					    (short)atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
			break;
		    case VLONG_IDEN:
			*(long *)*(long *)lpOpnd[j].values += \
					    atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
			break;
		    case VFLOAT_IDEN:
			*(double *)*(long *)lpOpnd[j].values += \
					    (double)atol( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
		} /* end of switch */
		break;
	     case FFIELD_IDEN:
		switch( lpOpnd[ j ].type ) {
		    case VCHR_IDEN:
			*(char *)*(long *)lpOpnd[j].values += \
					    (char)atof( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
			break;
		    case VINT_IDEN:
			*(short *)*(long *)lpOpnd[j].values += \
					    (short)atof( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
			break;
		    case VLONG_IDEN:
			*(long *)*(long *)lpOpnd[j].values += \
					    (long)atof( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
			break;
		    case VFLOAT_IDEN:
			*(double *)*(long *)lpOpnd[j].values += \
					    atof( SubstrOutBlank(p->pSourceStart, 0,\
					    lpOpnd[i].length) );
		} /* end of switch */
	     }
	}
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_x_SUM() */


/*------------
 !                      _ASK_RECORD()
 ! protocol: record
 !-----------------------------------------------------------------------*/
short PD_style _ASK_RECORD( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
{
    dFIELD *field;
    short   i;
    dFILE  *df, *tdf;
extern WSToMT FromToStru fFrTo;

    if( askTdf == (void *)1 ) {
	ErrorSet.xERROR = iRecordNoTO;      /* no this action */
	return  1;
    }
    if( *CurState > 0 ) {
/*// correct this problem 1995.3.7 for the source dFILE could be virtual
	PutRecord(p->pTargetDfile, p->pSourceDfile->rec_buf);
*/
	if( lpOpnd[0].type<FIELD_IDEN || lpOpnd[0].type>SFIELD_IDEN )
	    return  1;

	if( (tdf = fFrTo.targefile) == NULL )   return  1;

	//the df won't be NULL, for the Opnd point to a field
	df = ((dFIELDWHENACTION *)lpOpnd[0].oval)->pSourceDfile;
	field = df->field;

	if( deof( tdf ) )
	{
		//add one record first
		put1rec( tdf );
	}

	for( i = min(tdf->field_num,df->field_num)-1;   i >= 0;  i-- ) {
		if( field[i].fieldtype == 'M' || field[i].fieldtype == 'G') {
		    char        buf[260];
		    extern char tmpPath[MAXPATH];
		    short	newid;
		    dFILE	*df1;

		    sprintf(buf, "ILDIODBT.%03X", intOfThread&0xFFF);
		    makefilename(buf, tmpPath, buf);

		    //read the dbt into file
		    //dbtToFile(df, GetFldid(df, field[i].field), buf);
		    df1 = getRealDbfIdByName(field[i].field, &newid);
		    dbtToFile(df1, newid, buf);


		    //put_fld from file
		    dbtFromFile(tdf, i, buf);
		} else {
		    char        buf[260];

		    strncpy(buf, field[i].fieldstart, field[i].fieldlen);
		    buf[ field[i].fieldlen ] = '\0';
		    put_fld(tdf, i, buf);
		}
	}
	putrec( tdf );
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_RECORD() */


/*------------
 !                      _ASK_Delete()
 ! protocol: delete
 !-----------------------------------------------------------------------*/
short PD_style _ASK_Delete( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
{
    dFIELDWHENACTION *p;
extern WSToMT FromToStru fFrTo;

    if( *CurState > 0 ) {
	if( xIsOpndField(&lpOpnd[0]) == 0 )
	{
	    int i;
	    i = xGetOpndLong(&lpOpnd[0]) - 1;
	    if( i < 0 || i >= fFrTo.cSouDbfNum )
		return  1;

	    PutDelChar( fFrTo.cSouFName[i], '*' );
	    *OpndTop -= ParaNum;

	    return  0;
	} //////////////////////////////////////////////////////////////////

	p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	//if( p == NULL ) p = (dFIELDWHENACTION *)lpOpnd[0].values;
	if( p->pSourceDfile == NULL )   return  1;

	if( p->pSourceDfile->rec_p > 0 ) {
	    PutDelChar(p->pSourceDfile, '*');
	}

	/*1998.1.7 Xilong
	get1rec(p->pSourceDfile);
	if( p->pSourceDfile->rec_buf[0] == ' ' ) {
		p->pSourceDfile->rec_buf[0] = '*';
	} else {
		p->pSourceDfile->rec_buf[0] = ' ';
	}

	if( p->pSourceDfile->rec_p < p->pSourceDfile->firstDel )
	     p->pSourceDfile->firstDel = p->pSourceDfile->rec_p;

	put1rec(p->pSourceDfile);
	*/
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_Delete() */


/*------------
 !                      _ASK_Dbfpack()
 ! protocol: packdbf
 !-----------------------------------------------------------------------*/
short PD_style _ASK_Packdbf( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
{
    dFILE *tdf;
    int    i;
extern WSToMT FromToStru fFrTo;

//    if( *CurState != 0 && *CurState != LASTWORKTIMEOFACTION ) {
    if( *CurState == ONE_MODALITY_ACTION ) {
	if( xIsOpndField(&lpOpnd[0]) == 0 )
	{
	    i = xGetOpndLong(&lpOpnd[0]) - 1;
	    if( i < 0 || i >= fFrTo.cSouDbfNum )
		return  1;

	    tdf = fFrTo.cSouFName[i];
	} else {
	    tdf = ((dFIELDWHENACTION *)lpOpnd[0].oval)->pSourceDfile;
	    if( tdf == NULL )       return  1;
	}
	dpack( tdf );
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_Dbfpack() */


/*------------
 !                      _ASK_REC()
 ! protocol: askrec
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_REC( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
{
    short 	      i;
    unsigned short    j;
    dFIELDWHENACTION *p;
    unsigned char     buf[4096];
    dFILE            *sdf, *tdf;
extern WSToMT FromToStru fFrTo;

/*    if( *CurState == 0 ) {

	char *fld_name[256];

	p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	if( p == NULL ) p = (dFIELDWHENACTION *)lpOpnd[0].values;
	sdf = p->pSourceDfile;
	if( (tdf = p->pTargetDfile) == NULL )   return( 1 );
	j = getFieldNum(tdf);

	for(i = 0;  i < 255 && i < j;  i++)
		fld_name[i] = getFieldInfo(tdf,i)->field;
	fld_name[i] = NULL;
	field_ident(sdf, fld_name);

    } else */
    if( *CurState > 0 ) {

        if( lpOpnd[0].type<FIELD_IDEN || lpOpnd[0].type>SFIELD_IDEN )
            return  1;

	p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	sdf = p->pSourceDfile;
	if( (tdf = fFrTo.targefile) == NULL )   return  1;

	//NewRec( tdf );

	if( ParaNum < 2 && deof( tdf ) )
	{
		//add one record first
		put1rec( tdf );
	}

	for( i = tdf->field_num-1;   i >= 0;   i-- ) {
		if( (j = GetFldid(sdf, tdf->field[i].field)) != 0xFFFF ) {
		    if( tdf->field[i].fieldtype == 'M' ) {
			  char        buf[260];
			  extern char tmpPath[MAXPATH];
			  short	      newid;
			  dFILE	     *df1;

			  sprintf(buf, "ILDIODBT.%03X", intOfThread&0xFFF);
			  makefilename(buf, tmpPath, buf);

			  //read the dbt into file
			  //dbtToFile(sdf, j, buf);
			  df1 = getRealDbfIdByName(sdf->field[j].field, &newid);
			  dbtToFile(df1, newid, buf);

			  //put_fld from file
			  dbtFromFile(tdf, i, buf);
		    } else {
			  GetField(sdf, j, buf);
			  PutField(tdf, i, buf);
		    }
		}
	}

	if( ParaNum < 2 )
	{ //if askrec() has more than 1 parameter, just calculate the
	  //record, but don't put the record
	    putrec( tdf );
	} else {
	    for(i = 1;  i < ParaNum;  i++ ) {
		if( lpOpnd[i].type == STRING_TYPE && \
					lpOpnd[i].length >= MAX_OPND_LENGTH ) {
		    free((char *)*(long *)lpOpnd[i].values);
		}
	    }
	}

    } /* end of if */

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_REC() */


/*------------
 !                      _ASK_WriteStatistics()
 ! protocol: warray("tb01.dbf", x, y, z)
 !-----------------------------------------------------------------------*/
// #pragma argsused /* Remed by NiuJingyu */
short PD_style _ASK_WriteStatistics( OpndType *lpOpnd, short ParaNum, \
			    short *OpndTop, short *CurState )
{

    int        i, j, k, iStartX, decs;
    ArrayType *p;
    dFIELD    *field;
    int        fieldNum, rowNum;
    dFILE     *tb;
    unsigned char decimal, declen;
    char       buf[MAXPATH];

    field = NULL;
    fieldNum = 1;
    rowNum = 0;

    if( *CurState != ONE_MODALITY_ACTION ) {
	*OpndTop -= ParaNum;
	return  0;
    }

    if( lpOpnd[1].type == ARRAY_TYPE ) {
	iStartX = 1;
	decs = 2;
    } else {
	iStartX = 2;
	decs = xGetOpndLong(&lpOpnd[1]);
	if( decs == LONG_MIN || decs > 10 )
	    decs = 2;
    }

    /*if( *CurState == LASTWORKTIMEOFACTION ) */{              /* first work of this action */
	for( k = iStartX;  k < ParaNum;  k++ ) {

	    if( lpOpnd[k].type != ARRAY_TYPE )
		continue;

	    p = (ArrayType *)*(long *)lpOpnd[k].oval;
	    rowNum = max(p->ArrayDim[0], rowNum);
	    switch( p->ElementType ) {
		case INT_TYPE:
			decimal = 4;
			declen = 0;
			break;
		case LONG_TYPE:
			decimal = 10;
			declen = 0;
			break;
		case FLOAT_TYPE:
			decimal = 19;
			declen = decs;
			break;
		default:
			ErrorSet.xERROR = iNoMatchArray;
			return 1;
	    }

	    i = fieldNum - 1;
	    fieldNum += p->ArrayDim[1];
	    field = (dFIELD *)realloc(field, fieldNum*sizeof( dFIELD ) );
	    for( ;  i < fieldNum - 1;  i++ ) {
#ifdef WSToMT
		sprintf( field[i].field, "X%d", i+1 );
#else
		sprintf( field[i].field, "B%02d", i+1 );
#endif
		field[i].fieldtype = 'N';
		field[i].fieldlen = decimal;
		field[i].fielddec = declen;
	    }
	}
	field[i].field[0] = '\0';

	if( lpOpnd[0].oval == NULL ) {
		if( lpOpnd[0].length >= MAX_OPND_LENGTH ) {
			makefilename( buf, asqlEnv.szAsqlResultPath, \
					(char *)*(long *)lpOpnd[0].values);
			free( (char *)*(long *)lpOpnd[0].values );
		} else {
			makefilename(buf, asqlEnv.szAsqlResultPath, (char *)lpOpnd[0].values);
		}
	} else {
		makefilename(buf, asqlEnv.szAsqlResultPath, (char *)lpOpnd[0].oval);
	}

	if( dIsAwake(buf) )
	{ //the file has already open, if we recreare it, will destory it
	  //check the field, if they are the same, use the old one

		dFIELD *fld;

		tb = dAwake(buf, DOPENPARA);

		//i => the fieldnum
		for(i--;  i >= 0;  i--) {
			if( GetFldid(tb, field[i].field) == 0xFFFF )
				break;

			// check type and fielddec
			fld = getFieldInfo(tb, (short)i);
			fld->fieldtype = field[i].fieldtype;
			fld->fielddec = field[i].fielddec;
		}
		//the following is modified by Xilong
/*			if( fld->fieldtype != field[i].fieldtype || \
			    fld->fielddec != field[i].fielddec )
				break;
		}
		if( i >= 0 ) {
			dSleep(tb);
			ErrorSet.xERROR = 10002;		//file is already open
			return 1;
		}*/
		dzap(tb);
		dseek(tb, 0, SEEK_SET);
	} else {
		tb = dcreate(buf, field);
		//dSetAwake(tb, &tb);
	}
    
	if( tb == NULL ) {
		ErrorSet.xERROR = iFailCreateFile;
		return 1;
	}

	/* write the date num */
	for( i = 0;  i < rowNum;  i++ ) {

	    fieldNum = 0;
	    NewRec(tb);

	    for( k = iStartX;  k < ParaNum;  k++ ) {
		if( lpOpnd[k].oval == NULL ) {
			p = (ArrayType *)*(long *)lpOpnd[k].values;
		} else {
			p = (ArrayType *)*(long *)lpOpnd[k].oval;
		}
		for( j = 0;  j < p->ArrayDim[1];  j++ ) {

		   switch( p->ElementType ) {
			case CHR_TYPE:
				PutField( (dFILE *)tb, (short)(fieldNum++), \
					 (char *)p->ArrayMem + j + i * p->ArrayDim[1] );
				break;
			case INT_TYPE:
				PutField( (dFILE *)tb, (short)(fieldNum++), \
					 (char *)p->ArrayMem + 2 * ( j + i * p->ArrayDim[1] ) );
				break;
			case LONG_TYPE:
				PutField( (dFILE *)tb, (short)(fieldNum++), \
					(char *)p->ArrayMem + 4 * ( j + i * p->ArrayDim[1] ) );
				break;
			case FLOAT_TYPE:
				PutField( (dFILE *)tb, (short)(fieldNum++), \
					(char *)p->ArrayMem + sizeof(double) * ( j + i * p->ArrayDim[1] ) );
				break;
			default:
				dclose(tb);
				ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
				return 1;
		   } /* end of switch */
		} /* end of for(j) */

	    } // end of for(k)

	    putrec( tb );

	  } /* end of for(i) */

	  free( field );
	  //dSleep( tb );
	  dclose(tb);

    }

    *OpndTop -= ParaNum;

    return 0;

} /* end of function _ASK_WriteStatistics() */



/*------------
 !                      _ASK_ReadStatistics()
 ! rarray(str,array)
 !-----------------------------------------------------------------------*/
// #pragma argsused	/* Remed by NiuJingyu */
short PD_style _ASK_ReadStatistics( OpndType *lpOpnd, short ParaNum, \
			   short *OpndTop, short *CurState )
{
    unsigned short i, j;
    ArrayType     *p;
    dFILE         *tb;
    char           buf[MAXPATH];

    //if( ParaNum > 2 )   return 1;

    /*if( *CurState == LASTWORKTIMEOFACTION ) */              /* first work of this action */

    if( lpOpnd[0].oval == NULL ) {
	if( lpOpnd[0].length >= MAX_OPND_LENGTH ) {
		makefilename( buf, asqlEnv.szAsqlResultPath, \
					(char *)*(long *)lpOpnd[0].values);
		free( (char *)*(long *)lpOpnd[0].values );
	} else {
		makefilename(buf, asqlEnv.szAsqlResultPath, (char *)lpOpnd[0].values);
	}
    } else {
		makefilename(buf, asqlEnv.szAsqlResultPath, (char *)lpOpnd[0].oval);
    }

    tb = dopen(buf, DOPENPARA);

    if( tb == NULL ) {
	ErrorSet.xERROR = iFailFunCall;       /* file open error */
	return 1;
    }

    if( lpOpnd[1].oval == NULL ) {
	p = (ArrayType *)*(long *)lpOpnd[1].values;
    } else {
	p = (ArrayType *)*(long *)lpOpnd[1].oval;
    }

    // read the date num
    for( i = 0;  i < p->ArrayDim[0];  i++ ) {

	      getrec( tb );

	      for( j = 0;  j < p->ArrayDim[1];  j++ ) {

		   switch( p->ElementType ) {
			case CHR_TYPE:
				GetField( tb, j, \
					 (char *)p->ArrayMem + j + i * p->ArrayDim[1] );
				break;
			case INT_TYPE:
				GetField( tb, j, \
					 (char *)p->ArrayMem + 2 * ( j + i * p->ArrayDim[1] ) );
				break;
			case LONG_TYPE:
				GetField( tb, j, \
					(char *)p->ArrayMem + 4 * ( j + i * p->ArrayDim[1] ) );
				break;
			case FLOAT_TYPE:
				GetField( tb, j, \
					(char *)p->ArrayMem + sizeof(double) * ( j + i * p->ArrayDim[1] ) );
				break;
			default:
				dclose(tb);
				ErrorSet.xERROR = iNoMatchArray;       // error dim type
				return 1;
		   } // end of switch
	      } // end of for(j)
    } // end of for(i)

    dclose( tb );

    *OpndTop -= ParaNum;

    return 0;

} /* end of function _ASK_ReadStatistics() */




/*------------
 !                      _Ask_AsqlStat_X()
 ! protocol:
 !   statx(colNo,array)
 ! function:
 !   set the stat value
 !-----------------------------------------------------------------------*/
// #pragma argsused /* Remed by NiuJingyu */
short PD_style _Ask_AsqlStat_X( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
// parameter: array, dim  dim begin with 0
    ArrayType   *p;
    long	 DimSize;
    void        *vp;
    int          i;
    char        *myAsqlStatFlagY;
extern WSToMT char   *asqlStatFlagY;
extern WSToMT short  asqlStatMaxY;

    i = *CurState;
    if( i == 0 ) {
	if( lpOpnd[1].type != ARRAY_TYPE ) {
		ErrorSet.xERROR = iStatXPt;
		return 1;
	}
    } else if( i > 0 ) {


/*      if( lpOpnd[0].oval == NULL )
		p = (ArrayType *)*(long *)lpOpnd[0].values;
	else*/
        myAsqlStatFlagY = asqlStatFlagY;
	switch( (p = (ArrayType *)*(long *)lpOpnd[1].oval)->ElementType ) {
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
				(*(signed long *)((char *)vp+DimSize*i))++;
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
				(*(signed char *)((char *)vp+DimSize*i))++;
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + 2L * (*(long *)lpOpnd[0].values);
		DimSize = 2 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
				(*(signed short *)((char *)vp+DimSize*i))++;
		}
		break;
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double)*(*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
				(*(double *)((char *)vp+DimSize*i))++;
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } /* end of if */

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return 0;

} /* end of function _Ask_AsqlStat_X */



/*------------
 !                      _Ask_AsqlStat_Y()
 ! protocol:
 !   staty(lineNo)
 ! function:
 !   set the true Y
 !-----------------------------------------------------------------------*/
// #pragma argsused	/* Remed by NiuJingyu */
short PD_style _Ask_AsqlStat_Y( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    register short      i;
extern WSToMT char   *asqlStatFlagY;
extern WSToMT short  asqlStatMaxY;

    if( *CurState > 0 ) {
	i = (short)*(long *)lpOpnd[0].values;
	if( i < asqlStatMaxY )
		asqlStatFlagY[i] = 1;
    } // end of if

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return 0;

} /* end of function _Ask_AsqlStat_Y */



/*------------
 !                      _Ask_AsqlSum_X()
 ! protocol:
 !   sumx(colNo, array,fieldname,...  )
 ! function:
 !   set the stat value
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _Ask_AsqlSum_X( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    ArrayType   *p;
    long        DimSize;
    void        *vp;
    long        TempL;
    double      TempF;
    short       VarType;
    int         i;
    char        *myAsqlStatFlagY;
extern WSToMT char   *asqlStatFlagY;
extern WSToMT short  asqlStatMaxY;

    if( *CurState == 0 ) {
	if( lpOpnd[1].type != ARRAY_TYPE ) {
		ErrorSet.xERROR = iSumXPt;
		return 1;
	}

    } else if( *CurState > 0 ) {

	// get the field value into buffer
        myAsqlStatFlagY = asqlStatFlagY;
	TempL = 0;
	TempF = 0.0;
	VarType = NFIELD_IDEN;
	for(i = 2;  i < ParaNum;  i++ ) {
	switch( lpOpnd[i].type ) {
	    case NFIELD_IDEN:
/*need not in our define of NFIELD
		if( lpOpnd[i].oval == NULL )
			TempL += atol( substr(((dFIELDWHENACTION *)lpOpnd[i].values)->pSourceStart, \
			      0,lpOpnd[i].length) );
		else*/
			TempL += atol( subcopy(((dFIELDWHENACTION *)lpOpnd[i].oval)->pSourceStart, \
			      0,lpOpnd[i].length) );
		break;
	    case FFIELD_IDEN:
/*              if( lpOpnd[i].oval == NULL )
			TempF += atof( substr(((dFIELDWHENACTION *)lpOpnd[i].values)->pSourceStart, \
				0,lpOpnd[i].length) );
		else*/
			TempF += atof( subcopy(((dFIELDWHENACTION *)lpOpnd[i].oval)->pSourceStart, \
				0,lpOpnd[i].length) );
		VarType = FFIELD_IDEN;
		break;
	    case LONG_TYPE:
		TempL += *(long *)lpOpnd[i].values;
		break;
	    case CHR_TYPE:
		TempL += *(char *)lpOpnd[i].values;
		break;
	    case INT_TYPE:
		TempL += (long)*(short *)lpOpnd[i].values;
		break;
	    case FLOAT_TYPE:
		TempF += *(double *)lpOpnd[i].values;
		VarType = FFIELD_IDEN;
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;
		return 1;
	}
	} // end of for
	if( VarType == FFIELD_IDEN )    TempF += TempL;

/*      if( lpOpnd[0].oval == NULL )
		p = (ArrayType *)*(long *)lpOpnd[0].values;
	else*/
	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	switch( p->ElementType ) {              /* switch sum element type */
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 )
			  if( VarType == NFIELD_IDEN )
				(*(double *)((char *)vp+DimSize*i)) += TempL;
			  else
				(*(double *)((char *)vp+DimSize*i)) += TempF;
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 )
			  if( VarType == NFIELD_IDEN )
				(*(signed long *)((char *)vp+DimSize*i)) += TempL;
			  else
				(*(signed long *)((char *)vp+DimSize*i)) += (long)TempF;
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (long)(*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0],asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 )
			  if( VarType == NFIELD_IDEN )
				(*(signed char *)((char *)vp+DimSize*i)) += (char)TempL;
			  else
				(*(signed char *)((char *)vp+DimSize*i)) += (char)TempF;
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(short) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(short) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 )
			  if( VarType == NFIELD_IDEN )
				(*(signed short *)((char *)vp+DimSize*i)) += (short)TempL;
			  else
				(*(signed short *)((char *)vp+DimSize*i)) += (short)TempF;
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } /* end of if */

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return 0;

} /* end of function _Ask_AsqlSum_X */



/*------------
 !                      _Ask_AsqlMax_X()
 ! protocol:
 !   maxx(colNo, array,fieldname,...  )
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _Ask_AsqlMax_X( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    ArrayType   *p;
    long        DimSize;
    void        *vp;
    long        TempL, L;
    double      TempF, F;
    short       VarType;
    int         i, fcount;
    char        *myAsqlStatFlagY;
extern WSToMT char   *asqlStatFlagY;
extern WSToMT short  asqlStatMaxY;

    if( *CurState == 0 ) {
	if( lpOpnd[1].type != ARRAY_TYPE ) {
		ErrorSet.xERROR = iMaxXPt;
		return 1;
	}

	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	switch( p->ElementType ) {
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(double *)((char *)vp+DimSize*i)) = FLOAT_MIN;
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(signed long *)((char *)vp+DimSize*i)) = LONG_MIN;
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (long)(*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0],asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(signed char *)((char *)vp+DimSize*i)) = CHAR_MIN;
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(short) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(short) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(signed short *)((char *)vp+DimSize*i)) = SHRT_MIN;
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } else if( *CurState == LASTWORKTIMEOFACTION ) {
	if( lpOpnd[1].type != ARRAY_TYPE ) {
		ErrorSet.xERROR = iMinXPt;
		return 1;
	}

	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	switch( p->ElementType ) {
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(double *)((char *)vp+DimSize*i)) == FLOAT_MIN )
			(*(double *)((char *)vp+DimSize*i)) = 0.0;
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(signed long *)((char *)vp+DimSize*i)) == LONG_MIN )
			(*(signed long *)((char *)vp+DimSize*i)) = 0;
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (long)(*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0],asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(signed char *)((char *)vp+DimSize*i)) == CHAR_MIN )
			(*(signed char *)((char *)vp+DimSize*i)) = '\0';
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(short) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(short) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(signed short *)((char *)vp+DimSize*i)) == SHRT_MIN )
			(*(signed short *)((char *)vp+DimSize*i)) = 0;

		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } else if( *CurState > 0 ) {

	// get the field value into buffer
        myAsqlStatFlagY = asqlStatFlagY;
	TempL = LONG_MIN;
	TempF = DBL_MIN;
	VarType = NFIELD_IDEN;
	fcount = 0;

	for(i = 2;  i < ParaNum;  i++ ) {
	  switch( lpOpnd[i].type ) {
	    case NFIELD_IDEN:
		L = atol( subcopy(((dFIELDWHENACTION *)lpOpnd[i].oval)->pSourceStart, \
			      0,lpOpnd[i].length) );
		if( TempL < L )
		    TempL = L;
		break;
	    case FFIELD_IDEN:
		F = atof( subcopy(((dFIELDWHENACTION *)lpOpnd[i].oval)->pSourceStart, \
				0,lpOpnd[i].length) );
		if( TempF < F )
		    TempF = F;
		VarType = FFIELD_IDEN;
		fcount++;
		break;
	    case LONG_TYPE:
		L = *(long *)lpOpnd[i].values;
		if( TempL < L )
		    TempL = L;
		break;
	    case CHR_TYPE:
		L = *(char *)lpOpnd[i].values;
		if( TempL < L )
		    TempL = L;
		break;
	    case INT_TYPE:
		L = (long)*(short *)lpOpnd[i].values;
		if( TempL < L )
		    TempL = L;
		break;
	    case FLOAT_TYPE:
		F = *(double *)lpOpnd[i].values;
		if( TempF < F )
		    TempF = F;
		VarType = FFIELD_IDEN;
		fcount++;
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;
		return 1;
	  }
	} // end of for

	if( VarType == FFIELD_IDEN && TempF < TempL && fcount < ParaNum-1 )
	    TempF = TempL;

	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	switch( p->ElementType ) {
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 ) {
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(double *)((char *)vp+DimSize*i)) < TempL )
				(*(double *)((char *)vp+DimSize*i)) = TempL;
			  } else {
			     if( (*(double *)((char *)vp+DimSize*i)) < TempF )
				(*(double *)((char *)vp+DimSize*i)) = TempF;
			  }
		     }
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 ) {
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(signed long *)((char *)vp+DimSize*i)) < TempL )
				(*(signed long *)((char *)vp+DimSize*i)) = TempL;
			  } else {
			     if( (*(signed long *)((char *)vp+DimSize*i)) < (long)TempF )
				(*(signed long *)((char *)vp+DimSize*i)) = (long)TempF;
			  }
		     }
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (long)(*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0],asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 )
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(signed char *)((char *)vp+DimSize*i)) < TempL )
				(*(signed char *)((char *)vp+DimSize*i)) = (char)TempL;
			  } else {
			     if( (*(signed char *)((char *)vp+DimSize*i)) < (char)TempF )
				(*(signed char *)((char *)vp+DimSize*i)) = (char)TempF;
			  }
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(short) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(short) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 ) {
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(signed short *)((char *)vp+DimSize*i)) < TempL )
				(*(signed short *)((char *)vp+DimSize*i)) = (short)TempL;
			  } else {
			     if( (*(signed short *)((char *)vp+DimSize*i)) < (short)TempF )
				(*(signed short *)((char *)vp+DimSize*i)) = (short)TempF;
			  }
		     }
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } /* end of if */

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return 0;

} /* end of function _Ask_AsqlMax_X */



/*------------
 !                      _Ask_AsqlMin_X()
 ! protocol:
 !   minx(colNo, array,fieldname,...  )
 !-----------------------------------------------------------------------*/
//#pragma argsused	/* Remed by NiuJingyu */
short PD_style _Ask_AsqlMin_X( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    ArrayType   *p;
    long        DimSize;
    void        *vp;
    long        TempL, L;
    double      TempF, F;
    short       VarType;
    int         i, fcount;
    char        *myAsqlStatFlagY;
extern WSToMT char   *asqlStatFlagY;
extern WSToMT short  asqlStatMaxY;

    if( *CurState == 0 ) {
	if( lpOpnd[1].type != ARRAY_TYPE ) {
		ErrorSet.xERROR = iMinXPt;
		return 1;
	}

	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	switch( p->ElementType ) {
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(double *)((char *)vp+DimSize*i)) = FLOAT_MAX;
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(signed long *)((char *)vp+DimSize*i)) = LONG_MAX;
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (long)(*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0],asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(signed char *)((char *)vp+DimSize*i)) = CHAR_MAX;
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(short) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(short) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    (*(signed short *)((char *)vp+DimSize*i)) = SHRT_MAX;
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } else if( *CurState == LASTWORKTIMEOFACTION ) {
	if( lpOpnd[1].type != ARRAY_TYPE ) {
		ErrorSet.xERROR = iMinXPt;
		return 1;
	}

	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	switch( p->ElementType ) {
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(double *)((char *)vp+DimSize*i)) == FLOAT_MAX )
			(*(double *)((char *)vp+DimSize*i)) = 0.0;
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(signed long *)((char *)vp+DimSize*i)) == LONG_MAX )
			(*(signed long *)((char *)vp+DimSize*i)) = 0;
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (long)(*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0],asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(signed char *)((char *)vp+DimSize*i)) == CHAR_MAX )
			(*(signed char *)((char *)vp+DimSize*i)) = '\0';
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(short) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(short) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		    if( (*(signed short *)((char *)vp+DimSize*i)) == SHRT_MAX )
			(*(signed short *)((char *)vp+DimSize*i)) = 0;

		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } else if( *CurState > 0 ) {

	// get the field value into buffer
	myAsqlStatFlagY = asqlStatFlagY;
	TempL = LONG_MAX;
	TempF = DBL_MAX;
	VarType = NFIELD_IDEN;
	fcount = 0;

	for(i = 2;  i < ParaNum;  i++ ) {
	  switch( lpOpnd[i].type ) {
	    case NFIELD_IDEN:
		L = atol( subcopy(((dFIELDWHENACTION *)lpOpnd[i].oval)->pSourceStart, \
			      0,lpOpnd[i].length) );
		if( TempL > L )
		    TempL = L;
		break;
	    case FFIELD_IDEN:
		F = atof( subcopy(((dFIELDWHENACTION *)lpOpnd[i].oval)->pSourceStart, \
				0,lpOpnd[i].length) );
		if( TempF > F )
		    TempF = F;
		VarType = FFIELD_IDEN;
		fcount++;
		break;
	    case LONG_TYPE:
		L = *(long *)lpOpnd[i].values;
		if( TempL > L )
		    TempL = L;
		break;
	    case CHR_TYPE:
		L = *(char *)lpOpnd[i].values;
		if( TempL > L )
		    TempL = L;
		break;
	    case INT_TYPE:
		L = (long)*(short *)lpOpnd[i].values;
		if( TempL > L )
		    TempL = L;
		break;
	    case FLOAT_TYPE:
		F = *(double *)lpOpnd[i].values;
		if( TempF > F )
		    TempF = F;
		VarType = FFIELD_IDEN;
		fcount++;
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;
		return 1;
	  }
	} // end of for
	if( VarType == FFIELD_IDEN && TempF > TempL && fcount < ParaNum-1 )
	    TempF = TempL;

	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	switch( p->ElementType ) {              /* switch sum element type */
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 ) {
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(double *)((char *)vp+DimSize*i)) > TempL )
				(*(double *)((char *)vp+DimSize*i)) = TempL;
			  } else {
			     if( (*(double *)((char *)vp+DimSize*i)) > TempF )
				(*(double *)((char *)vp+DimSize*i)) = TempF;
			  }
		     }
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 ) {
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(signed long *)((char *)vp+DimSize*i)) > TempL )
				(*(signed long *)((char *)vp+DimSize*i)) = TempL;
			  } else {
			     if( (*(signed long *)((char *)vp+DimSize*i)) > (long)TempF )
				(*(signed long *)((char *)vp+DimSize*i)) = (long)TempF;
			  }
		     }
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (long)(*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0],asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 )
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(signed char *)((char *)vp+DimSize*i)) > TempL )
				(*(signed char *)((char *)vp+DimSize*i)) = (char)TempL;
			  } else {
			     if( (*(signed char *)((char *)vp+DimSize*i)) > (char)TempF )
				(*(signed char *)((char *)vp+DimSize*i)) = (char)TempF;
			  }
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(short) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(short) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
		     if( myAsqlStatFlagY[i] != 0 ) {
			  if( VarType == NFIELD_IDEN ) {
			     if( (*(signed short *)((char *)vp+DimSize*i)) > TempL )
				(*(signed short *)((char *)vp+DimSize*i)) = (short)TempL;
			  } else {
			     if( (*(signed short *)((char *)vp+DimSize*i)) > (short)TempF )
				(*(signed short *)((char *)vp+DimSize*i)) = (short)TempF;
			  }
		     }
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } /* end of if */

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return 0;

} /* end of function _Ask_AsqlMin_X */



/*------------
 !                      _Ask_AsqlAvg_X()
 ! protocol:
 ! average(colNum, countArray, sumArray, fieldname,...  )
 !-----------------------------------------------------------------------*/
// #pragma argsused	/* Remed by NiuJingyu */
short PD_style _Ask_AsqlAvg_X( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    ArrayType *p, *p1;
    long       MemSize, DimSize, DimSize1;
    char      *vp, *vp1;
    short      mOpndTop;

    if( *CurState == 0 ) {
	if( lpOpnd[1].type != ARRAY_TYPE || lpOpnd[2].type != ARRAY_TYPE ) {
	    ErrorSet.xERROR = iAvgXPt;
	    *OpndTop -= ParaNum;
	    return  1;
	}
	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	p1 = (ArrayType *)*(long *)lpOpnd[2].oval;

	if( (p1->ArrayDim[1] != p->ArrayDim[1]) || \
				      (p1->ArrayDim[0] != p->ArrayDim[0]) ) {
	    ErrorSet.xERROR = iAvgXPt;
	    *OpndTop -= ParaNum;
	    return  1;
	}

	*OpndTop -= ParaNum;
	return  0;
    }

    if( *CurState > 0 ) {
	mOpndTop = *OpndTop;

	//1999.11.5 Xilong Pei
	if( ParaNum > 4 ) {

	    num_Ask_AsqlStat_X(lpOpnd, 2, &mOpndTop, CurState,
						&lpOpnd[ParaNum-1]);
	    mOpndTop = *OpndTop;
	    memcpy(&lpOpnd[1], &lpOpnd[0], sizeof(OpndType));
	    _Ask_AsqlSum_X(&lpOpnd[1], (short)(ParaNum-2), &mOpndTop, CurState);
	} else {
	    _Ask_AsqlStat_X(lpOpnd, 2, &mOpndTop, CurState);
	    mOpndTop = *OpndTop;
	    memcpy(&lpOpnd[1], &lpOpnd[0], sizeof(OpndType));
	    _Ask_AsqlSum_X(&lpOpnd[1], (short)(ParaNum-1), &mOpndTop, CurState);
	}
	*OpndTop -= ParaNum;
	return  0;

    } else if( *CurState == LASTWORKTIMEOFACTION ) {

	p = (ArrayType *)*(long *)lpOpnd[1].oval;
	p1 = (ArrayType *)*(long *)lpOpnd[2].oval;
	switch( p1->ElementType ) {
	    case CHR_TYPE:
		vp1 = (char *)p1->ArrayMem + (*(long *)lpOpnd[0].values);
		DimSize1 = p1->ArrayDim[1];
		break;
	    case INT_TYPE:
		vp1 = (char *)p1->ArrayMem + 2L * (*(long *)lpOpnd[0].values);
		DimSize1 = 2 * p1->ArrayDim[1];
		break;
	    case LONG_TYPE:
		vp1 = (char *)p1->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize1 = 4 * p1->ArrayDim[1];
		break;
	    case FLOAT_TYPE:
		vp1 = (char *)p1->ArrayMem + sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize1 = sizeof(double) * p->ArrayDim[1];
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */
	switch( p->ElementType ) {              /* switch count element type */
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		switch( p1->ElementType ) {
			case CHR_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
					*(signed char *)vp1 /= *(signed char *)vp;
					vp += DimSize;
					vp1 += DimSize1;
				}
				break;
			case INT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
					*(signed short *)vp1 /= *(signed char *)vp;
					vp += DimSize;
					vp1 += DimSize1;
				}
				break;
			case LONG_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
					*(signed long *)vp1 /= *(signed char *)vp;
					vp += DimSize;
					vp1 += DimSize1;
				}
				break;
			case FLOAT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
					*(double *)vp1 /= *(signed char *)vp;
					vp += DimSize;
					vp1 += DimSize1;
				}
				break;
			default:
				return  1;
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + 2L * (*(long *)lpOpnd[0].values);
		DimSize = 2 * p->ArrayDim[1];
		switch( p1->ElementType ) {
			case CHR_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed short *)vp != 0 )
					*(char *)vp1 /= *(signed short *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case INT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed short *)vp != 0 )
					*(short *)vp1 /= *(signed short *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case LONG_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed short *)vp != 0 )
					*(long *)vp1 /= *(signed short *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case FLOAT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed short *)vp != 0 )
					*(double *)vp1 /= *(signed short *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			default:
				return  1;
		}
		break;
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		switch( p1->ElementType ) {
			case CHR_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed long *)vp != 0 )
					*(char *)vp1 /= *(signed char *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case INT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed long *)vp != 0 )
					*(signed short *)vp1 /= *(signed short *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case LONG_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed long *)vp != 0 )
					*(long *)vp1 /= *(signed long *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case FLOAT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(signed long *)vp != 0 )
					*(double *)vp1 /= *(signed long *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			default:
				return  1;
		}
		break;
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + sizeof(double) * (*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		switch( p1->ElementType ) {
			case CHR_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(double *)vp != 0 )
					*(char *)vp1 /= (char)*(double *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case INT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(double *)vp != 0 )
					*(signed short *)vp1 /= (short)*(double *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case LONG_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(double *)vp != 0 )
					*(long *)vp1 /= (long)*(double *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			case FLOAT_TYPE:
				for( MemSize = p->ArrayDim[0];   MemSize > 0;   MemSize-- ) {
				   if( *(double *)vp != 0 )
					*(double *)vp1 /= *(double *)vp;
				   vp += DimSize;
				   vp1 += DimSize1;
				}
				break;
			default:
				return  1;
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;
		return 1;
	} /* end of switch */
    } // end of else

    *OpndTop -= ParaNum;
    return  0;

}  /* end of function _Ask_AsqlAvg_X */


/*------------
 !                       _ASK_DbfUnion
 !-----------------------------------------------------------------------*/
//#pragma argsused
short PD_style _ASK_UniteDbf( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    unsigned short i;
    char *dbf[32];

    if( *CurState == ONE_MODALITY_ACTION ) {              /* first work of this action */

	for( i = 2;    i < ParaNum;   i++ ) {
		if( lpOpnd[i].oval == NULL )
			dbf[i-2] = lpOpnd[i].values;
		else
			dbf[i-2] = lpOpnd[i].oval;
	}
	if( lpOpnd[0].oval == NULL ) {
		if( lpOpnd[1].oval == NULL )
			DbfUniteOneToMore( (short)(ParaNum-2), lpOpnd[0].values, lpOpnd[1].values, dbf );
		else
			DbfUniteOneToMore( (short)(ParaNum-2), lpOpnd[0].values, lpOpnd[1].oval, dbf );
	} else {
		if( lpOpnd[1].oval == NULL )
			DbfUniteOneToMore( (short)(ParaNum-2), lpOpnd[0].values, lpOpnd[1].oval, dbf );
		else
			DbfUniteOneToMore( (short)(ParaNum-2), lpOpnd[0].oval, lpOpnd[1].oval, dbf );
	}
    }

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return  0;

} // end of function _ASK_UniteDbf()



/*------------
 !                       _ASK_InsetDbf
 !-----------------------------------------------------------------------*/
//#pragma argsused
short PD_style _ASK_InsetDbf( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    unsigned short i;
    char *dbf[32];

    if( *CurState == ONE_MODALITY_ACTION ) {              /* first work of this action */

	for( i = 2;    i < ParaNum;   i++ ) {
		dbf[i-2] = lpOpnd[i].values;
	}
	DbfInterSection( (short)(ParaNum-2), lpOpnd[0].values, lpOpnd[1].values, dbf );
    }

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return  0;

} // end of function _ASK_InsetDbf()


/*------------
 !                      _ASK_VIEWNO()
 !-----------------------------------------------------------------------*/
short PD_style _ASK_VIEWNO( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
{
    dFIELDWHENACTION *p;
    long        l;
    dFILE  *df, *tdf;
extern WSToMT FromToStru fFrTo;

    if( *CurState > 0 ) {

	if( (tdf = fFrTo.targefile) == NULL )   return  1;

	if( xIsOpndField(&lpOpnd[0]) == 0 )
	{
	    int i;
	    i = xGetOpndLong(&lpOpnd[0]) - 1;

	    if( i < 0 || i >= fFrTo.cSouDbfNum )
		return  1;

	    df = fFrTo.cSouFName[i];
	} else {
	    if( lpOpnd[0].oval == NULL ) {
		p = (dFIELDWHENACTION *)lpOpnd[0].values;
	    } else {
		p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	    }

	    df = p->pSourceDfile;
    	    //if( p->pTargetDfile == NULL )   return  1;
	}

	NewRec( tdf );
	l = df->rec_p;
	PutField(tdf, GetFldid(tdf, VIEW_RECNO_FIELD), &l );
	putrec( tdf );
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_VIEWNO() */



/*------------
 !                       _ASK_DbfZap
 ! protocol:  zap(char*)
 !-----------------------------------------------------------------------*/
//#pragma argsused
short PD_style _ASK_DbfZap( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    unsigned short i;
    char     dbfName[MAXPATH];
    dFILE    *df;
    char     *s;
extern WSToMT FromToStru fFrTo;

    for( i = 0;    i < ParaNum;   i++ ) {
	 if( lpOpnd[i].type == STRING_TYPE ) {
	     s = xGetOpndString(&lpOpnd[i]);
	     if( s != NULL ) {

		if( *s != '^' ) {
		    makefilename(dbfName, asqlEnv.szAsqlResultPath, s);
		} else {
		    makefilename(dbfName, asqlEnv.szAsqlFromPath, s);
		}

		df = dAwake(dbfName, DOPENPARA);
		if( df != NULL ) {
			dzap(df);
			dSleep(df);
		}
	     }
	} else {
	     long l;

	     if( xIsOpndField(&lpOpnd[i]) ) {
		df = fFrTo.targefile;
		dzap(df);
	     } else {
		l = xGetOpndLong(&lpOpnd[i]);
		if( (l >= 1) && (l <= fFrTo.cSouDbfNum) ) {
			df = fFrTo.cSouFName[i];
			dzap(df);
		}
	     }
	}
    }

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return  0;

} // end of function _ASK_DbfZap()



/*------------
 !                       _ASK_FillTable
 ! protocol:  filltable(char *key, char *dataFld, void *data)
 !            key, dataFld, data can be field type or string type
 !
 ! DO generate field when the field doesn't exist
 !-----------------------------------------------------------------------*/
//#pragma argsused
short PD_style _ASK_FillTable( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    char  key[256];
    char  dataFld[32];
    char  data[256];
    long   l;
    short  i, j;

    dFIELDWHENACTION *p;
extern WSToMT FromToStru fFrTo;

    if( *CurState == 0 ) {

	char *field[2];

	p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	field[0] = p->pTargetDfile->field[0].field;
	field[1] = NULL;
	fFrTo.tTree = IndexBuild((char *)(p->pTargetDfile), field, p->pTargetDfile->name, BTREE_FOR_OPENDBF);
    } else if( *CurState > 0 ) {

	//get the keyword
	p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	if( lpOpnd[0].type == STRING_TYPE ) {
	   if( p == NULL ) {
		if( lpOpnd[0].length >= MAX_OPND_LENGTH ) {
			strZcpy(key, (char *)*(long *)lpOpnd[0].values, 256);
			free((char *)*(long *)lpOpnd[0].values);
		} else {
			strZcpy(key, lpOpnd[0].values, 256);
		}
	   } else {
		strZcpy(key, lpOpnd[0].oval, 256);
	   }
	} else {
	   strZcpy(key, subcopy(p->pSourceStart, 0,lpOpnd[0].length), 256);
	}

	//locate it
	l = IndexSeek(fFrTo.tTree, key);
	if( l == LONG_MIN ) {
		NewRec(fFrTo.tTree->dbfPtr);
		dseek(fFrTo.tTree->dbfPtr, 0, dSEEK_END);
		PutField(fFrTo.tTree->dbfPtr, 0, key);
		IndexSyncDbf(fFrTo.tTree, NULL);
	} else {
		get1rec(fFrTo.tTree->dbfPtr);
	}

	for(j = 1;   j < ParaNum;    j++ ) {
	   //get field
	   p = (dFIELDWHENACTION *)lpOpnd[j].oval;
	   if( lpOpnd[j].type == STRING_TYPE ) {
		if( p == NULL ) {
			if( lpOpnd[j].length >= MAX_OPND_LENGTH ) {
				strZcpy(dataFld, (char *)*(long *)lpOpnd[j].values, 32);
				free((char *)*(long *)lpOpnd[j].values);
			} else {
				strZcpy(dataFld, lpOpnd[j].values, 32);
			}
		} else {
			strZcpy(dataFld, lpOpnd[j].oval, 32);
		}
	   } else {
		strZcpy(dataFld, subcopy(p->pSourceStart, 0,lpOpnd[j].length), 32);
	   }

	   //get data
	   j++;
	   p = (dFIELDWHENACTION *)lpOpnd[j].oval;
	   if( lpOpnd[j].type == STRING_TYPE ) {
		if( p == NULL ) {
			if( lpOpnd[j].length >= MAX_OPND_LENGTH ) {
				strZcpy(data, (char *)*(long *)lpOpnd[j].values, 256);
				free((char *)*(long *)lpOpnd[j].values);
			} else {
				strZcpy(data, lpOpnd[j].values, 256);
			}
		} else {
			strZcpy(data, lpOpnd[j].oval, 256);
		}
	   } else {
		strZcpy(data, subcopy(p->pSourceStart, 0,lpOpnd[j].length), 256);
	   }

	   //!!!the difference between filltable and gentable
	   i = GetFldid(fFrTo.tTree->dbfPtr, dataFld);
	   if( i < 0 ) {
		i = changeFldName(fFrTo.tTree->dbfPtr, -1, dataFld);
	   }
	   //!!!

	   if( i >= 0 ) {
		PutField(fFrTo.tTree->dbfPtr, i, data);
		put1rec(fFrTo.tTree->dbfPtr);
	   }
	} // end of for
    } else {
	IndexClose(fFrTo.tTree);
	fFrTo.tTree = NULL;
    }
    *OpndTop -= ParaNum;                // maintain the opnd stack

    return  0;

} // end of function _ASK_FillTable()



/*------------
 !                       _ASK_GenTable
 ! protocol:  gentable(char *key, char *dataFld, void *data)
 !            key, dataFld, data can be field type or string type
 !
 ! DON'T generate field when the field doesn't exist
 !-----------------------------------------------------------------------*/
//#pragma argsused
short PD_style _ASK_GenTable( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState )
{
    char  key[256];
    char  dataFld[32];
    char  data[256];
    long   l;
    short  i, j;

    dFIELDWHENACTION *p;
extern WSToMT FromToStru fFrTo;

    if( *CurState == 0 ) {

	char *field[2];

	p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	field[0] = p->pTargetDfile->field[0].field;
	field[1] = NULL;
	fFrTo.tTree = IndexBuild((char *)(p->pTargetDfile), field, p->pTargetDfile->name, BTREE_FOR_OPENDBF);
    } else if( *CurState > 0 ) {

	//get the keyword
	p = (dFIELDWHENACTION *)lpOpnd[0].oval;
	if( lpOpnd[0].type == STRING_TYPE ) {
	   if( p == NULL ) {
		if( lpOpnd[0].length >= MAX_OPND_LENGTH ) {
			strZcpy(key, (char *)*(long *)lpOpnd[0].values, 256);
			free((char *)*(long *)lpOpnd[0].values);
		} else {
			strZcpy(key, lpOpnd[0].values, 256);
		}
	   } else {
		strZcpy(key, lpOpnd[0].oval, 256);
	   }
	} else {
	   strZcpy(key, subcopy(p->pSourceStart, 0,lpOpnd[0].length), 256);
	}

	//locate it
	l = IndexSeek(fFrTo.tTree, key);
	if( l == LONG_MIN ) {
		goto ExistGenTable;
	} else {
		get1rec(fFrTo.tTree->dbfPtr);
	}

	for(j = 1;   j < ParaNum;    j++ ) {
	   //get field
	   p = (dFIELDWHENACTION *)lpOpnd[j].oval;
	   if( lpOpnd[j].type == STRING_TYPE ) {
		if( p == NULL ) {
			if( lpOpnd[j].length >= MAX_OPND_LENGTH ) {
				strZcpy(dataFld, (char *)*(long *)lpOpnd[j].values, 32);
				free((char *)*(long *)lpOpnd[j].values);
			} else {
				strZcpy(dataFld, lpOpnd[j].values, 32);
			}
		} else {
			strZcpy(dataFld, lpOpnd[j].oval, 32);
		}
	   } else {
		strZcpy(dataFld, subcopy(p->pSourceStart, 0,lpOpnd[j].length), 32);
	   }

	   //get data
	   j++;
	   p = (dFIELDWHENACTION *)lpOpnd[j].oval;
	   if( lpOpnd[j].type == STRING_TYPE ) {
		if( p == NULL ) {
			if( lpOpnd[j].length >= MAX_OPND_LENGTH ) {
				strZcpy(data, (char *)*(long *)lpOpnd[j].values, 256);
				free((char *)*(long *)lpOpnd[j].values);
			} else {
				strZcpy(data, lpOpnd[j].values, 256);
			}
		} else {
			strZcpy(data, lpOpnd[j].oval, 256);
		}
	   } else {
		strZcpy(data, subcopy(p->pSourceStart, 0,lpOpnd[j].length), 256);
	   }

	   i = GetFldid(fFrTo.tTree->dbfPtr, dataFld);
	   if( i >= 0 ) {
		PutField(fFrTo.tTree->dbfPtr, i, data);
		put1rec(fFrTo.tTree->dbfPtr);
	   }
	} // end of for
    } else {
	IndexClose(fFrTo.tTree);
	fFrTo.tTree = NULL;
    }

ExistGenTable:
    *OpndTop -= ParaNum;                // maintain the opnd stack

    return  0;

} // end of function _ASK_GenTable()



/*------------
 !                      _ASK_SigmaY()
 ! protocol: sigmay(x, startY, endY, targetY)
 !-----------------------------------------------------------------------*/
//#pragma argsused
short PD_style _ASK_SigmaY( OpndType *lpOpnd, short ParaNum, \
					short *OpndTop, short *CurState )
{

    long    startY, endY, targetY;
    long    tempL;
    double  tempF;
    int	    i, j;
    int	    colNum;
    ArrayType *p;

    if( *CurState != ONE_MODALITY_ACTION ) {
	*OpndTop -= ParaNum;
	return  0;
    }

    if( lpOpnd[0].type != ARRAY_TYPE ) {
	ErrorSet.xERROR = iTypeNoCompt;
	return 1;
    }

    startY = xGetOpndLong( &(lpOpnd[1]) ) - 1;
    endY = xGetOpndLong( &(lpOpnd[2]) ) - 1;
    targetY = xGetOpndLong( &(lpOpnd[3]) ) - 1;
    p = (ArrayType *)*(long *)lpOpnd[0].oval;

    if( startY < 0 || startY >= p->ArrayDim[0] || \
				endY < 0 || endY >= p->ArrayDim[0] || \
				targetY < 0 || targetY >= p->ArrayDim[0] )
    {
	ErrorSet.xERROR = iSigmaYP;
	return 1;
    }

    colNum = p->ArrayDim[1];

    switch( p->ElementType ) {
      case FLOAT_TYPE:
	for( i = 0;  i < colNum;  i++ ) {

	  tempF = 0.0;
	  for(j = startY;  j <= endY;  j++) {
	    tempF += *(double *)((char *)p->ArrayMem + sizeof(double)*(i+j*colNum));
	  }

	  *(double *)((char *)p->ArrayMem + sizeof(double)*(i+targetY*colNum)) += tempF;
	}
      break;

      case LONG_TYPE:
	for( i = 0;  i < colNum;  i++ ) {

	  tempL = 0;
	  for(j = startY;  j <= endY;  j++) {
	    tempL += *(long *)((char *)p->ArrayMem + 4*(i+j*colNum));
	  }

	  *(long *)((char *)p->ArrayMem + 4*(i+targetY*colNum)) += tempL;
	}
      break;

      case INT_TYPE:
	for( i = 0;  i < colNum;  i++ ) {

	  tempL = 0;
	  for(j = startY;  j <= endY;  j++) {
	    tempL += *(short *)((char *)p->ArrayMem + 4*(i+j*colNum));
	  }

	  *(short *)((char *)p->ArrayMem + 2*(i+targetY*colNum)) += (short)tempL;
	}
      break;

      case CHR_TYPE:
	for( i = 0;  i < colNum;  i++ ) {

	  tempL = 0;
	  for(j = startY;  j <= endY;  j++) {
	    tempL += *(long *)((char *)p->ArrayMem + (i+j*colNum));
	  }

	  *(char *)((char *)p->ArrayMem + (i+targetY*colNum)) += (char)tempL;
	}
      break;
    }

    *OpndTop -= ParaNum;

    return 0;

} //_ASK_SigmaY()


/*------------
 !                      _ASK_SigmaX()
 ! protocol: sigmay(x, startX, endX, targetX)
 !-----------------------------------------------------------------------*/
//#pragma argsused
short PD_style _ASK_SigmaX( OpndType *lpOpnd, short ParaNum, \
					short *OpndTop, short *CurState )
{
    long    startX, endX, targetX;
    long    tempL;
    double  tempF;
    int	    i, j;
    int	    colNum, rowNum;
    ArrayType *p;

    if( *CurState != ONE_MODALITY_ACTION ) {
	*OpndTop -= ParaNum;
	return  0;
    }

    if( lpOpnd[0].type != ARRAY_TYPE ) {
	ErrorSet.xERROR = iTypeNoCompt;
	return 1;
    }

    startX = xGetOpndLong( &(lpOpnd[1]) ) - 1;
    endX = xGetOpndLong( &(lpOpnd[2]) ) - 1;
    targetX = xGetOpndLong( &(lpOpnd[3]) ) - 1;
    p = (ArrayType *)*(long *)lpOpnd[0].oval;

    if( startX < 0 || startX >= p->ArrayDim[1] || \
				endX < 0 || endX >= p->ArrayDim[1] || \
				targetX < 0 || targetX >= p->ArrayDim[1] )
    {
	ErrorSet.xERROR = iSigmaXP;
	return 1;
    }

    colNum = p->ArrayDim[1];
    rowNum = p->ArrayDim[0];

    switch( p->ElementType ) {
      case FLOAT_TYPE:
	for( i = 0;  i < rowNum;  i++ ) {
	  tempF = 0.0;
	  for(j = startX;  j <= endX;  j++) {
	     tempF += *(double *)((char *)p->ArrayMem + sizeof(double)*(j+i*colNum));
	  }
	  *(double *)((char *)p->ArrayMem + sizeof(double)*(targetX+i*colNum)) += tempF;
	}
      break;

      case LONG_TYPE:
	for( i = 0;  i < rowNum;  i++ ) {
	  tempL = 0;
	  for(j = startX;  j <= endX;  j++) {
	     tempL += *(long *)((char *)p->ArrayMem + 4*(j+i*colNum));
	  }
	  *(long *)((char *)p->ArrayMem + sizeof(long)*(targetX+i*colNum)) += tempL;
	}
      break;

      case INT_TYPE:
	for( i = 0;  i < rowNum;  i++ ) {
	  tempL = 0;
	  for(j = startX;  j <= endX;  j++) {
	     tempL += *(short *)((char *)p->ArrayMem + 2*(j+i*colNum));
	  }
	  *(short *)((char *)p->ArrayMem + sizeof(short)*(targetX+i*colNum)) += (short)tempL;
	}
      break;

      case CHR_TYPE:
	for( i = 0;  i < rowNum;  i++ ) {
	  tempL = 0;
	  for(j = startX;  j <= endX;  j++) {
	     tempL += *(char *)((char *)p->ArrayMem + (j+i*colNum));
	  }
	  *(char *)((char *)p->ArrayMem + (targetX+i*colNum)) += (char)tempL;
	}
      break;
    }

    *OpndTop -= ParaNum;

    return 0;

} //_ASK_SigmaX()



/*------------
 !                      _ASK_Goto()
 !-----------------------------------------------------------------------*/
short PD_style _ASK_Goto( OpndType *lpOpnd, short ParaNum, \
					short *OpndTop, short *CurState )
{
    char  *s;
extern WSToMT FromToStru fFrTo;

    s = xGetOpndString(&lpOpnd[0]);
    if( s == NULL )
	return  1;

    strZcpy(fFrTo.jmpLabel, lrtrim(s), 32);
    lpOpnd[0].type = LONG_TYPE;
    *(long *)(lpOpnd[0].values) = (LONG_MAX-16);

    *OpndTop -= ParaNum - 1;    /* maintain the opnd stack */

    return  0;

} /* end of function _ASK_Goto() */



/*------------
 !                      _ASK_NextMainRec()
 ! nextmrec()
 !-----------------------------------------------------------------------*/
short PD_style _ASK_NextMainRec( OpndType *lpOpnd, short ParaNum, \
					short *OpndTop, short *CurState )
{
    int  i;
extern WSToMT FromToStru fFrTo;

    i = xGetOpndLong(&lpOpnd[0]);
    if( (i >= 1) && (i <= fFrTo.cSouDbfNum) )
	fFrTo.mtSkipThisSet[i-1] = '\1';

    fFrTo.nextMainRec = '\1';
    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return  0;

} /* end of function _ASK_NextMainRec() */


/*------------
 !                      _ASK_Web_Print()
 ! webstream
 !-----------------------------------------------------------------------*/
short PD_style _ASK_Web_Print( OpndType *lpOpnd, short ParaNum, \
					short *OpndTop, short *CurState )
{
    char  *s;
    short i;
    TS_COM_PROPS tscp;
    char  lpsz[4096];
    short packLen, j;

    if( *CurState == 0 || *CurState == LASTWORKTIMEOFACTION ) {
	*OpndTop -= ParaNum;    /* maintain the opnd stack */
	return  0;
    }

    tscp.leftPacket = '\1';	//no use: there are any other packet to transmit
    tscp.endPacket = '\1';  //not end, DONNOT GIVE UP
    tscp.packetType = 'R';
    tscp.msgType = 'Z';
    tscp.lp = 0;
    memcpy(lpsz, &tscp, sizeof(TS_COM_PROPS));
    packLen = 0;

    for(i = 0;   i < ParaNum;   i++)
    {
	if( lpOpnd[i].type == MFIELD_IDEN ) {
	    long memSize;
	    dFIELDWHENACTION *p;
	    TS_COM_PROPS tscp1;

	    p = (dFIELDWHENACTION *)lpOpnd[i].oval;

	    s = blobToMem(p->pSourceDfile, p->wSourceid, &memSize);
	    if( s == NULL ) {
		s = "";
		memSize = 1;
	    }

	    {
		//
		//tscp.leftPacket = '\1';	//no use: there are any other packet to transmit
		//tscp.endPacket = '\1';  //not end, DONNOT GIVE UP
		tscp1.packetType = 'R';
		tscp1.msgType = 'Z';
		//tscp.lp = 0;
		if( SrvWriteExchngBufEx((EXCHNG_BUF_INFO *)wmtExbuf, \
						  &tscp1,
						  s,
						  memSize,
						  0) != 0 ) {
		    //agent shell error
		    *OpndTop -= ParaNum;    /* maintain the opnd stack */
		    free(s);
		    return  1;
		}
		free(s);
		continue;
	    }
	}

	if( lpOpnd[i].type == ARRAY_TYPE )
	{
	    ArrayType   *pa;
	    TS_COM_PROPS tscp1;

	    pa = (ArrayType *)*(long *)lpOpnd[i].oval;

	    //
	    //tscp.leftPacket = '\1';	//no use: there are any other packet to transmit
	    //tscp.endPacket = '\1';  //not end, DONNOT GIVE UP
	    tscp1.packetType = 'R';
	    tscp1.msgType = 'Z';
	    //tscp.lp = 0;
	    if( SrvWriteExchngBufEx((EXCHNG_BUF_INFO *)wmtExbuf, \
						  &tscp1,
						  pa->ArrayMem,
						  pa->MemSize,
						  0) != 0 ) {
		//agent shell error
		*OpndTop -= ParaNum;    /* maintain the opnd stack */
		return  1;
	    }
	    continue;
	}

	s = xGetOpndString(&lpOpnd[i]);
	if( s != NULL ) {
		//memset(&tscp, 0, sizeof(TS_COM_PROPS));

	    j = strlen(s)+1;
	    if( j > MAX_PKG_MSG_LEN-sizeof(TS_COM_PROPS) )
	    { //cut the string
		j = MAX_PKG_MSG_LEN-sizeof(TS_COM_PROPS);
		s[MAX_PKG_MSG_LEN-sizeof(TS_COM_PROPS)-1] = '\0';
	    }

	    if( j > MAX_PKG_MSG_LEN-packLen ) {
		tscp.len = packLen;
		if( SrvWriteExchngBuf((EXCHNG_BUF_INFO *)wmtExbuf, lpsz, packLen+sizeof(TS_COM_PROPS)) != 0 )
		{
		    //agent shell error
		    *OpndTop -= ParaNum;
		    return  1;
		}
		tscp.leftPacket = '\1';	//no use: there are any other packet to transmit
		tscp.endPacket = '\1';  //not end, DONNOT GIVE UP
		tscp.packetType = 'R';
		tscp.msgType = 'Z';
		tscp.lp = 0;
		memcpy(lpsz, &tscp, sizeof(TS_COM_PROPS));
		packLen = 0;
	    }
	    memcpy(&lpsz[packLen], s, j);
	    packLen += j;
	}
    }

    if( packLen > sizeof(TS_COM_PROPS) ) {
	tscp.len = packLen;
	if( SrvWriteExchngBuf((EXCHNG_BUF_INFO *)wmtExbuf, lpsz, packLen+sizeof(TS_COM_PROPS)) != 0 )
	{
	    //agent shell error
	    *OpndTop -= ParaNum;
	    return  1;
	}
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return  0;

} /* end of function _ASK_Web_Print() */


/*------------
 !                      _ASK_MVIEWNO()
 ! 1998.2.24
 ! mvewno(fieldname)
 ! notice: one ASQL task can have just one mvewno()
 !-----------------------------------------------------------------------*/
short PD_style _ASK_MVIEWNO( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		short *CurState )
{
    long        l;
    int		i;
    TS_COM_PROPS tscp;
    char  lpsz[4096];
extern WSToMT FromToStru fFrTo;
//WSToMT short    in4096Buf;
//WSToMT char     s4096Buf[4096];

    if( *CurState == 0 ) {
	in4096Buf = 0;
    } else if( *CurState == LASTWORKTIMEOFACTION ) {
	//generate the packet and post them
	memset(&tscp, 0, sizeof(TS_COM_PROPS));
	tscp.endPacket = '\1';
	tscp.packetType = 'R';
	tscp.msgType = 'X';
	tscp.len = in4096Buf;
	//tscp.lp = 0;
	memcpy(lpsz, &tscp, sizeof(TS_COM_PROPS));
	memcpy(&lpsz[sizeof(TS_COM_PROPS)], s4096Buf, tscp.len);
	if( SrvWriteExchngBuf((EXCHNG_BUF_INFO *)wmtExbuf, lpsz, in4096Buf+sizeof(TS_COM_PROPS)) != 0 )
	{
	    //agent shell error
	    *OpndTop -= ParaNum;    /* maintain the opnd stack */
	    return  1;
	}
    } else {

	if( xIsOpndField(&lpOpnd[0]) == 1 )
	{
	    l =  ((dFIELDWHENACTION *)lpOpnd[0].oval)->pSourceDfile->rec_p;
	} else {
	    i = xGetOpndLong(&lpOpnd[0]) - 1;
	    if( i >= 0 && i < fFrTo.cSouDbfNum )
	    { //2000.6.24
		l = getRecP( fFrTo.cSouFName[i] );
		//l = fFrTo.cSouFName[i]->rec_p;
	    } else
		l = -1;
	}

	*(long *)&s4096Buf[in4096Buf] = l;
	in4096Buf += 4;
	if( in4096Buf + 4 >= MAX_PKG_MSG_LEN ) {
	    //memset(&tscp, 0, sizeof(TS_COM_PROPS));
	    tscp.leftPacket = '\1';
	    tscp.endPacket = '\1';
	    tscp.packetType = 'R';
	    tscp.msgType = 'X';
	    tscp.len = in4096Buf;
	    //tscp.lp = 0;
	    memcpy(lpsz, &tscp, sizeof(TS_COM_PROPS));
	    memcpy(&lpsz[sizeof(TS_COM_PROPS)], s4096Buf, tscp.len);
	    if( SrvWriteExchngBuf((EXCHNG_BUF_INFO *)wmtExbuf, lpsz, 4096) != 0  )
	    {
		//agent shell error
		*OpndTop -= ParaNum;    /* maintain the opnd stack */
		return  1;
	    }
	    in4096Buf = 0;
	}
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return( 0 );

} /* end of function _ASK_MVIEWNO() */


/*------------
 !                      _ASK_Web_Bpnt()
 ! 1998.3.26
 ! webprint
 !-----------------------------------------------------------------------*/
short PD_style _ASK_Web_Bpnt( OpndType *lpOpnd, short ParaNum, \
					short *OpndTop, short *CurState )
{
    char	*s, *sv;
    short	i;
    TS_COM_PROPS tscp;
    char	lpsz[4096];

    if( *CurState == 0 || *CurState == LASTWORKTIMEOFACTION ) {
	*OpndTop -= ParaNum;    /* maintain the opnd stack */
	return  0;
    }

    for(i = 0;   i < ParaNum;   i++)
    {

	if( lpOpnd[i].type == MFIELD_IDEN ) {
	    long 		memSize;
	    dFIELDWHENACTION 	*p;
	    TS_COM_PROPS 	tscp1;

	    p = (dFIELDWHENACTION *)lpOpnd[i].oval;

	    s = blobToMem(p->pSourceDfile, p->wSourceid, &memSize);
	    if( (sv = s) == NULL ) {
		s = "";
		memSize = 1;
	    }

	    {
		//
		//tscp.leftPacket = '\1';	//no use: there are any other packet to transmit
		//tscp.endPacket = '\1';  //not end, DONNOT GIVE UP
		tscp1.packetType = 'R';
		tscp1.msgType = 'W';
		//tscp.lp = 0;
		if( SrvWriteExchngBufEx((EXCHNG_BUF_INFO *)wmtExbuf, \
						  &tscp1,
						  s,
						  memSize,
						  0) != 0 ) {
		    //agent shell error
		    *OpndTop -= ParaNum;    /* maintain the opnd stack */

		    if( sv != NULL )
			free(sv);
		    return  1;
		}

		if( sv != NULL )
		    free(sv);
		continue;
	    }
	}

	s = xGetOpndString(&lpOpnd[i]);
	if( s != NULL ) {
		//memset(&tscp, 0, sizeof(TS_COM_PROPS));
		tscp.leftPacket = '\1';	//no use: there are any other packet to transmit
		tscp.endPacket = '\1';  //not end, DONNOT GIVE UP
		tscp.packetType = 'R';
		tscp.msgType = 'W';
		tscp.len = min(strlen(s)+1, MAX_PKG_MSG_LEN);
		tscp.lp = (long)tscp.len;
		memcpy(lpsz, &tscp, sizeof(TS_COM_PROPS));
		memcpy(&lpsz[sizeof(TS_COM_PROPS)], s, tscp.len);
		if( SrvWriteExchngBuf((EXCHNG_BUF_INFO *)wmtExbuf, lpsz, \
					tscp.len+sizeof(TS_COM_PROPS)) != 0 )
		{
		    //agent shell error
		    *OpndTop -= ParaNum;    /* maintain the opnd stack */
		    return  1;
		}
	}
    }

    *OpndTop -= ParaNum;    /* maintain the opnd stack */

    return  0;

} //end of _ASK_Web_Bpnt()



/*------------
 !                      num_Ask_AsqlStat_X()
 !-----------------------------------------------------------------------*/
// #pragma argsused /* Remed by NiuJingyu */
short PD_style num_Ask_AsqlStat_X( OpndType *lpOpnd, short ParaNum, short *OpndTop, \
		       short *CurState, OpndType *numlpOpnd )
{
// parameter: array, dim  dim begin with 0
    ArrayType   *p;
    long	 DimSize;
    void        *vp;
    int          i;
    double	 f;
    long	 l;
    int		 num;
    char        *myAsqlStatFlagY;
extern WSToMT char   *asqlStatFlagY;
extern WSToMT short  asqlStatMaxY;

    i = *CurState;
    if( i == 0 ) {
	if( lpOpnd[1].type != ARRAY_TYPE ) {
		ErrorSet.xERROR = iStatXPt;
		return 1;
	}
    } else if( i > 0 ) {


/*      if( lpOpnd[0].oval == NULL )
		p = (ArrayType *)*(long *)lpOpnd[0].values;
	else*/
	num = 0;
	switch( numlpOpnd->type ) {
	    case CHR_TYPE:
	    case CHR_IDEN:
		l = (long)*(char *)numlpOpnd->values;
		break;
	    case LONG_TYPE:
	    case LONG_IDEN:
		l = *(long *)numlpOpnd->values;
		break;
	    case INT_TYPE:
	    case INT_IDEN:
		l = *(short *)numlpOpnd->values;
		break;
	    case FLOAT_TYPE:
	    case FLOAT_IDEN:
		f = *(double *)numlpOpnd->values;
		num = 1;
		break;
	    case NFIELD_IDEN:
		l = atol( subcopy((char *)*(long *)numlpOpnd->oval, 0, numlpOpnd->length) );
		break;
	    case FFIELD_IDEN:
		f = (double)atof( subcopy((char *)*(long *)numlpOpnd->oval, 0, numlpOpnd->length) );
		num = 1;
		break;
	    default:
		l = 1;
	} //end of switch

	myAsqlStatFlagY = asqlStatFlagY;
	switch( (p = (ArrayType *)*(long *)lpOpnd[1].oval)->ElementType ) {
	    case LONG_TYPE:
		vp = (char *)p->ArrayMem + 4L * (*(long *)lpOpnd[0].values);
		DimSize = 4 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
			    if( num )
				(*(signed long *)((char *)vp+DimSize*i)) += (long)f;
			    else
				(*(signed long *)((char *)vp+DimSize*i)) += l;
		}
		break;
	    case CHR_TYPE:
		vp = (char *)p->ArrayMem + (*(long *)lpOpnd[0].values);
		DimSize = p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
			    if( num )
				(*(signed char *)((char *)vp+DimSize*i)) += (char)f;
			    else
				(*(signed char *)((char *)vp+DimSize*i)) += (char)l;
		}
		break;
	    case INT_TYPE:
		vp = (char *)p->ArrayMem + 2L * (*(long *)lpOpnd[0].values);
		DimSize = 2 * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
			    if( num )
				(*(signed short *)((char *)vp+DimSize*i)) += (short)f;
			    else
				(*(signed short *)((char *)vp+DimSize*i)) += (short)l;
		}
		break;
	    case FLOAT_TYPE:
		vp = (char *)p->ArrayMem + (long)sizeof(double)*(*(long *)lpOpnd[0].values);
		DimSize = sizeof(double) * p->ArrayDim[1];
		for( i = min(p->ArrayDim[0], asqlStatMaxY)-1;  i >= 0;   i-- ) {
			if( myAsqlStatFlagY[i] != 0 )
			    if( num )
				(*(double *)((char *)vp+DimSize*i)) += f;
			    else
				(*(double *)((char *)vp+DimSize*i)) += (double)l;
		}
		break;
	    default:
		ErrorSet.xERROR = iNoMatchArray;       /* error dim type */
		return 1;
	} /* end of switch */

    } /* end of if */

    *OpndTop -= ParaNum;                /* maintain the opnd stack */

    return 0;

} /* end of function _Ask_AsqlStat_X */






/*********************** end of file: askact.c ******************************/
